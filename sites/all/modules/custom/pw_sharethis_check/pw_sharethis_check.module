<?php

/**
 * @File
 * Registers the alias to the sharethis_check.php
 */

include_once 'pw_sharethis_check.config.inc';
include_once 'pw_sharethis_check.api.inc';

/**
 * Implements hook_cron()
 */
function pw_sharethis_check_cron() {
//  pw_sharethis_check_iterateNodes('queue'); // updated all queued nodes
//  pw_sharethis_check_iterateNodes('migration'); // updates non-existant nodes 
//  pw_sharethis_check_iterateUsers('queue');
  pw_sharethis_check_iterateUsers('migration');
    
}

function pw_sharethis_check_menu() {
  $items['admin/config/sharethis_check/settings'] = array (
        'title' => 'ShareThis Check settings',
        'page callback' => 'pw_sharethis_check_options',
        'type' => MENU_NORMAL_ITEM,
        'access arguments' => array('administer site configuration'),
    );
  $items['sharethis_check'] = array(
    'page callback' => 'pw_sharethis_check_update',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}

function pw_sharethis_check_update() {
  $url = htmlspecialchars($_GET['url']);
  
  $record['url'] = $url; // TODO: prüfung auf sinnhaftigkeit:
  // 1. /profile/<username>/archive/<revisionnumber> -> Benutzer nach Benutzernamen laden. --> uid, revisionnumber (können wir auch ignorieren und einfach en bloc alle Revisionen aktualisieren)
  // 2. /petitionen/<name> und /petitions/<name> -> von diesem String die Source aus dem Alias holen --> nid
  // 3. blog/<artikelname> -> von diesem String die Source aus dem Alias holen --> nid
  // 4. <username>/question/<datum>/<nid> -> [von diesem String die Source aus dem Alias holen, eigentlich nicht nötig, da die NID in der URL drin ist] --> nid
  // Laden von URL-Alias reicht nicht: Die Archivprofile sind da nicht drin... Aber bei allen nodes sollte das gehen.
  
  $record['entity_id'] = 0;
  $record['revision_id'] = 0;
  $record['entity_type'] = 0;
  
  $doInsert = true;
  if (substr_count($url, '/profile/') == 1) {
    $urlArr = explode('/', $url);
    $usernameKey = array_search('profile', $urlArr) + 1;
    if (array_key_exists($usernameKey, $urlArr)) {
      $username = $urlArr[$usernameKey];
      $user = user_load_by_name($username);
      if ($user) {
        $record['entity_id'] = $user->uid;
      } else {
        $doInsert = false;
      }
    } else {
      $doInsert = false;
    }
    
    $revisionKey = array_search('archive', $urlArr) + 1;
    if (array_key_exists($revisionKey, $urlArr)) {
      $revisionId = (int)$urlArr[$revisionKey];
      $record['revision_id'] = $revisionId;
    }
    
    $record['entity_type'] = 'user';
  } else if (substr_count($url, '/petition') == 1 || substr_count($url, '/blog') == 1) { // works for /petitionen and /petitions
    $urlArr = explode('/', $url);
    $record['entity_type'] = 'node';
    if (array_key_exists(3, $urlArr) && array_key_exists(4, $urlArr)) {
      $sourcePath = drupal_lookup_path('source', $urlArr[3].'/'.$urlArr[4]);
      if ($sourcePath && substr_count($sourcePath, 'node') == 1) {
        $record['entity_id'] = (int)str_replace('node/', '', $sourcePath);
      } else {
        $doInsert = false;
      }
    } else {
      $doInsert = false;
    }
            
  } else if (substr_count($url, '/question/') == 1) {
      $urlArr = explode('/', $url);
      $record['entity_type'] = 'node';
      $questionKey = count($urlArr) - 1;
      $questionNid = (int)$urlArr[$questionKey];
      $record['entity_id'] = $questionNid;
  } else {
    $doInsert = false;
  }
  
  if ($doInsert) {
    db_insert('sharethis_queue')
      ->fields($record)
      ->execute();  
  }
}
