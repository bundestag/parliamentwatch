<?php

/**
 * @file
 * Module for the dialogue import.
 */
include_once 'pw_dialogues.features.inc';

/**
 * A buffer of overlap between the imports in seconds.
 */
define('PW_DIALOGUES_INTERVAL', 86400); // one day buffer

/**
 * Implements hook_menu().
 */
function pw_dialogues_menu() {
  $items['dialogues/%taxonomy_term'] = [
    'title callback' => 'pw_dialogues_page_title',
    'title arguments' => [1],
    'page callback' => 'pw_dialogues_page',
    'page arguments' => [1],
    'access arguments' => ['access content'],
    'type' => MENU_CALLBACK,
  ];
  $items['dialogues/%taxonomy_term/%'] = [
    'title callback' => 'pw_dialogues_page_title',
    'title arguments' => [1, 2],
    'page arguments' => [1, 2],
    'access arguments' => ['access content'],
    'type' => MENU_CALLBACK,
  ];
  $items['admin/config/pw/dialogues/settings'] = [
    'title' => 'Dialogue importer',
    'description' => 'Configure the source URL for the dialogue importer.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pw_dialogues_admin_settings_form'),
    'access arguments' => array('import dialogue_importer feeds'),
    'file' => 'pw_dialogues.admin.inc',
  ];
  $items['admin/config/pw/dialogues'] = [
    'title' => 'Dialogue importer',
    'description' => 'Mass re-import dialogues.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pw_dialogues_admin_reimport'),
    'access arguments' => array('import dialogue_importer feeds'),
    'file' => 'pw_dialogues.admin.inc',
  ];
  $items['api/import/dialogue/%'] = [
    'title' => 'imports dialogue',
    'access arguments' => array('access content'),
    'page callback' => 'pw_dialogues_triggered_import',
    'type' => MENU_SUGGESTED_ITEM,
  ];
  return $items;
}

/**
 * Implements hook_block_info().
 */
function pw_dialogues_block_info() {
  $blocks['profile'] = [
    'info' => t('Questions and answers'),
    'cache' => DRUPAL_NO_CACHE,
  ];
  $blocks['recent'] = [
    'info' => t('Recent questions and answers (in parliament)'),
    'cache' => DRUPAL_NO_CACHE,
  ];
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function pw_dialogues_block_view($delta) {
  switch ($delta) {
    case 'profile':
      return pw_dialogues_profile_block();
    case 'recent':
      return pw_dialogues_recent_block();
  }
}

/**
 * Implements hook_cron().
 *
 * Imports all dialogues once at night. Normally all dialogues should be
 * already imported by push request to api/import/dialogue/% via the moderation
 * backend.
 */
function pw_dialogues_cron() {

  // get import base url
  if ($source = variable_get('pw_dialogues_importer_source')) {

    // append the updated_since GET parameter to the source URL.
    if ($last_import = variable_get('pw_dialogues_importer_last_import', 0)) {

      // import only every X days / hours/ etc
      if ($last_import < time() - PW_DIALOGUES_INTERVAL) {

        // import buffer: 1.5 of import interval
        $updated_since_timestamp = $last_import - PW_DIALOGUES_INTERVAL * 1.5;
        $updated_since = date('Y-m-d\\TH:i:s', $updated_since_timestamp);
        if (strpos($source, '?') === FALSE) {
          $source .= '?updated_since=' . $updated_since;
        }
        else {
          $source .= '&updated_since=' . $updated_since;
        }

        // do the import
        pw_dialogues_do_import_questions($source);
        pw_dialogues_do_import_answers($source);

        // trigger userarchive cron which
        if (function_exists('pw_userarchives_cron')) {

          // query which politicians have a changed question and answer count.
          $users = db_query('SELECT DISTINCT f.field_dialogue_recipient_target_id
            FROM {field_data_field_dialogue_recipient} AS f
            INNER JOIN {feeds_item} AS i ON f.entity_type = i.entity_type AND f.entity_id = i.entity_id
            WHERE i.imported >= :imported', array(':imported' => $updated_since_timestamp))->fetchCol();

          // rewrite user archive cache table
          foreach ($users as $uid) {
            pw_userarchives_cron($uid);
          }
        }

        // save last import date
        variable_set('pw_dialogues_importer_last_import', REQUEST_TIME);
      }
    }
  }
}

/**
 * Implements hook_node_view().
 */
function pw_dialogues_node_view($node, $view_mode) {
  if ($node->type != 'dialogue') {
    return;
  }

  $comment = pw_dialogues_answer($node);

  if ($comment) {
    $node->content['answer'] = comment_view($comment, $node, $view_mode);
  }

  if (node_is_page($node)) {
    $parliament_tid = $node->field_parliament[LANGUAGE_NONE][0]['tid'];
    if ($node->field_dialogue_before_election[LANGUAGE_NONE][0]['value']) {
      menu_tree_set_path('main-menu', "profiles/$parliament_tid/candidates");
    }
    else {
      menu_tree_set_path('main-menu', "profiles/$parliament_tid/deputies");
    }
  }
}

/**
 * Implements hook_entity_presave().
 *
 * Modifies data on dialogue save (or import via api).
 */
function pw_dialogues_entity_presave($entity, $type) {

  // Force URL alias for dialogues
  if ($type == 'node' && $entity->type == 'dialogue' && isset($entity->nid)) {
    module_load_include('inc', 'pathauto');
    $entity->path['pathauto'] = TRUE;
    $alias_action = variable_get('pathauto_update_action', 0);
    variable_set('pathauto_update_action', PATHAUTO_UPDATE_ACTION_DELETE);
    $entity->path = pathauto_node_update_alias($entity, 'update');
    variable_set('pathauto_update_action', $alias_action);
  }
}

/**
 * Implements hook_feeds_presave().
 */
function pw_dialogues_feeds_presave(FeedsSource $source, $entity, $item) {

  if ($source->id == 'dialogue_importer' || $source->id == 'dialogue_message_importer') {

    // delete and skip item instead of importing
    if (!$entity->status) {

      // skip item
      $entity->feeds_item->skip = TRUE;

      // delete dialogue node (question)
      if ($entity->nid && !isset($entity->cid)) {
        entity_delete("node", $entity->nid);
      }

      // delete dialogue comments (answers)
      elseif ($entity->cid) {
        entity_delete("comment", $entity->cid);
      }
    }

    // remove empty attachments
    elseif (isset($entity->field_dialogue_documents['und'][0]['url']) && empty($entity->field_dialogue_documents['und'][0]['url'])) {
      $entity->field_dialogue_documents = NULL;
    }
    else {

      // add title to link
      foreach ($entity->field_dialogue_documents['und'] as &$document) {
        $document['title'] = basename($document['url']);
      }
    }
  }
}

/**
 * Implements hook_theme().
 */
function pw_dialogues_theme() {
  return [
    'dialogues_stats' => [
      'variables' => [
        'questions' => NULL,
        'answers' => NULL,
        'answer_ratio' => NULL,
        'average_response_time' => NULL,
      ],
      'template' => 'dialogues-stats',
    ],
  ];
}

/**
 * Title callback: Sets the title for the dialogues page.
 */
function pw_dialogues_page_title($parliament_term, $uid = NULL) {
  if (!isset($uid)) {
    return t('Questions to deputies in @parliament', ['@parliament' => $parliament_term->name]);
  }
  else {
    return t('Questions to @name', ['@name' => _pw_get_fullname(user_load($uid))]);
  }
}

/**
 * Page callback: Displays questions and answers for the given parliament.
 */
function pw_dialogues_page($parliament_term, $uid = NULL) {
  $limit = 12;
  $q = search_api_query('node_index');
  $q->condition('type', 'dialogue');
  $q->condition('field_parliament', $parliament_term->tid);

  if (isset($uid)) {
    $q->condition('field_dialogue_recipient', $uid);
  }

  if (isset(drupal_get_query_parameters()['keywords'])) {
    $f = $q->createFilter('OR');
    $f->condition('body:value', drupal_get_query_parameters()['keywords']);
    $f->condition('comments:field_dialogue_comment_body:value', drupal_get_query_parameters()['keywords']);
    $q->filter($f);
  }

  $response = $q
    ->sort('created', 'DESC')
    ->range(pager_find_page() * $limit, $limit)
    ->execute();

  if ($response['result count'] > 0) {
    pager_default_initialize($response['result count'], $limit);
    $build = node_view_multiple(node_load_multiple(array_keys($response['results'])), 'tile');
    $build['#theme_wrappers'] = ['container__tiles'];
    $build['nodes']['#modifier'] = 'qa';
    $build['pager'] = [
      '#theme' => 'pager',
      '#weight' => 5,
    ];
  }
  else {
    $build = [
      '#markup' => t('Sorry, there are no results matching your query.'),
    ];
  }

  return $build;
}

/**
 * Page callback: Imports questions.
 */
function pw_dialogues_triggered_import() {
  drupal_add_http_header('Content-type', 'text/plain; charset=utf8');
  $debug_message = array();
  $debug_message['request_uri'] = request_uri();
  $return_value = 'FAILED';
  if (is_numeric(arg(3))) {

    // prepare for import
    $dialogue_id = arg(3);
    $source = variable_get('pw_dialogues_importer_source');
    $source .= $dialogue_id;
    $source .= '?unreleased=1';
    $debug_message['source'] = $source;

    // retrieve what to do (delete, create, ...)
    $doc = new DOMDocument();
    $doc->preserveWhiteSpace = false;
    $doc->load($source);
    $xpath = new DOMXpath($doc);
    $xlist_status = $xpath->query("//message[type='question']/status");
    $xnode_status = $xlist_status->item(0)->nodeValue;

    // do import
    pw_dialogues_do_import_questions($source);

    // check if dialogue was imported
    $efq_nodes = new EntityFieldQuery();
    $efq_nodes->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'dialogue')
      ->fieldCondition('field_dialogue_id', 'value', $dialogue_id);
    $result = $efq_nodes->execute();
    $debug_message['result'] = $result;

    // dialogue found
    if (isset($result['node'])) {
      $dialogue_nid = key($result['node']);
      $node = node_load($dialogue_nid);
      $recipient_id = $node->field_dialogue_recipient['und'][0]['target_id'];

      // delete answers and re-import them
      /* $sql = "SELECT cid FROM {comment} WHERE nid=:nid";
        $cids_to_delete = db_query($sql, array(':nid' => $dialogue_nid))->fetchCol();
        $debug_message['cids_to_delete'] = $cids_to_delete;
        comment_delete_multiple($cids_to_delete); */
      pw_dialogues_do_import_answers($source);

      // set return_value to OK
      if (is_numeric($recipient_id) && ($user = user_load($recipient_id)) || $node->status != 1) {
        $return_value = 'OK';
        if (function_exists('pw_userarchives_cron')) {
          pw_userarchives_cron($recipient_id);
        }
      }
    }

    // node deleted
    elseif ($xnode_status != 1 && !isset($result['node'])) {
      $return_value = 'OK';
    }
  }

  _pw_send_debug_mail('Import ' . $return_value . ': ' . request_uri(), $debug_message);
  print $return_value;
}

/**
 * Displays the questions and answers section of a profile.
 *
 * @return array
 *   The block render array.
 */
function pw_dialogues_profile_block() {
  $block = [];

  if (menu_get_item()['page_callback'] == 'user_revision_show') {
    $map = menu_get_item()['original_map'];
    $account = user_revision_load($map[1], $map[3]);
  }
  else {
    $account = menu_get_object('user');
  }

  if (!$account) {
    return $block;
  }

  $block['subject'] = t('Questions and Answers');
  $result = pw_dialogues_by_user_revision_query($account)->execute();

  if (!empty($result['node'])) {
    $nodes = node_load_multiple(array_keys($result['node']));
    $inline_js = 'window.dialogues = ' . drupal_json_encode(pw_dialogues_topics_by_user_revision($account));
    $block['content'] = node_view_multiple(array_slice($nodes, 0, 12, TRUE), 'embedded');
    $block['content']['nodes']['#theme_wrappers'] = ['container__swiper'];
    $block['content']['stats'] = [
      '#theme' => 'dialogues_stats',
      '#questions' => $account->number_of_questions,
      '#answers' => $account->number_of_answers,
      '#answer_ratio' => round(100 * $account->number_of_answers / $account->number_of_questions, 0),
      '#average_response_time' => round(pw_dialogues_average_response_time_by_account($account) / 86400),
    ];
    $block['content']['stats']['#attached']['js'][$inline_js] = [
      'scope' => 'footer',
      'type' => 'inline',
    ];
    $block['overview_url'] = url('dialogues/' . pw_profiles_parliament($account)->tid . '/' . $account->uid);
  }
  $block['content']['question_form'] = node_view(node_load(10446), 'form');

  return $block;
}

/**
 * Displays the questions and answers section of a profile.
 *
 * @return array
 *   The block render array.
 */
function pw_dialogues_recent_block() {
  $block = [
    'subject' => t('Questions and answers'),
  ];
  $term = menu_get_object('taxonomy_term', 2);

  if (!$term || $term->vocabulary_machine_name != 'parliaments') {
    return $block;
  }

  $result = pw_dialogues_by_parliament_query($term)
    ->propertyOrderBy('created', 'DESC')
    ->range(0, 4)
    ->execute();

  if (!empty($result['node'])) {
    $nodes = node_load_multiple(array_keys($result['node']));
    $inline_js = 'window.dialogues = ' . drupal_json_encode(pw_dialogues_topics_by_parliament($term)) . ';';
    $questions = pw_dialogues_by_parliament_query($term)->count()->execute();
    $answers = pw_dialogues_answered_questions_by_parliament($term);
    $block['content'] = node_view_multiple($nodes, 'embedded');
    $block['content']['stats'] = [
      '#theme' => 'dialogues_stats',
      '#questions' => $questions,
      '#answers' => $answers,
      '#answer_ratio' => round(100 * $answers / $questions, 0),
      '#average_response_time' => round(pw_dialogues_average_response_time_by_parliament($term) / 86400),
      '#weight' => -5,
    ];
    $block['content']['stats']['#attached']['js'][$inline_js] = [
      'scope' => 'footer',
      'type' => 'inline',
    ];
  }

  return $block;
}

/**
 * Starts feeds import.
 */
function pw_dialogues_do_import_questions($source) {

  // Import dialogues (questions).
  $dialogue_feed = feeds_source('dialogue_importer');
  $dialogue_feed->addConfig(array(
    'FeedsHTTPFetcher' => array(
      'source' => $source,
    ),
  ));
  while (FEEDS_BATCH_COMPLETE != $dialogue_feed->import()) {
    ;
  }

  watchdog('dialogue_importer', 'questions imported from @source', ['@source' => $source]);

  return TRUE;
}

function pw_dialogues_do_import_answers($source) {

  // Import messages (answers).
  $message_feed = feeds_source('dialogue_message_importer');
  $message_feed->addConfig(array(
    'FeedsHTTPFetcher' => array(
      'source' => $source,
    ),
  ));
  while (FEEDS_BATCH_COMPLETE != $message_feed->import()) {
    ;
  }

  watchdog('dialogue_message_importer', 'answers imported from @source', ['@source' => $source]);

  return TRUE;
}

/**
 * Returns query for all questions received by the given account version.
 *
 * @param object $account
 *   The user account (version).
 *
 * @return EntityFieldQuery
 *   The query object.
 */
function pw_dialogues_by_user_revision_query($account) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'node');
  $q->entityCondition('bundle', 'dialogue');
  $q->propertyCondition('status', NODE_PUBLISHED);
  $q->fieldCondition('field_dialogue_recipient', 'target_id', $account->uid);
  $q->fieldCondition('field_parliament', 'tid', pw_profiles_parliament($account)->tid);
  $q->fieldCondition('field_dialogue_before_election', 'value', _pw_user_has_role($account, 'Candidate'));

  return $q;
}

/**
 * Returns query for all questions to politicians in the given parliament.
 *
 * @param object $term
 *   The parliament term.
 *
 * @return EntityFieldQuery
 *   The query object.
 */
function pw_dialogues_by_parliament_query($term) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'node');
  $q->entityCondition('bundle', 'dialogue');
  $q->propertyCondition('status', NODE_PUBLISHED);
  $q->fieldCondition('field_parliament', 'tid', $term->tid);

  return $q;
}

/**
 * Returns the answer to the given question.
 *
 * @param object $node
 *   The dialogue node.
 *
 * @return object
 *   The comment by the politician.
 */
function pw_dialogues_answer($node) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'comment');
  $q->propertyCondition('status', COMMENT_PUBLISHED);
  $q->propertyCondition('nid', $node->nid);
  $q->range(0, 1);
  $q->addTag('node_access');
  $q->addTag('comment_filter');

  $result = $q->execute();

  if (!empty($result['comment'])) {
    return comment_load(key($result['comment']));
  }
}

/**
 * Returns the average response time in seconds for the given user.
 *
 * @param object $account
 *   The user account.
 *
 * @return int
 *   The average response time in seconds.
 */
function pw_dialogues_average_response_time_by_account($account) {
  $sql = ""
    . "SELECT AVG(field_dialogue_response_time_value) "
    . "FROM {field_data_field_dialogue_response_time} "
    . "WHERE bundle = 'comment_node_dialogue' "
    . "AND entity_id IN (SELECT cid FROM {comment} WHERE uid = :uid)";
  return db_query($sql, [':uid' => $account->uid])->fetchField();
}

/**
 * Returns the average response time in seconds for the given parliament.
 *
 * @param object $term
 *   The parliament term.
 *
 * @return int
 *   The average response time in seconds.
 */
function pw_dialogues_average_response_time_by_parliament($term) {
  $sql = ""
    . "SELECT AVG(field_dialogue_response_time_value) "
    . "FROM {field_data_field_dialogue_response_time} rt "
    . "JOIN {comment} c ON rt.entity_id = c.cid "
    . "JOIN {field_data_field_parliament} p ON c.nid = p.entity_id "
    . "WHERE rt.bundle = 'comment_node_dialogue' "
    . "AND p.field_parliament_tid = :tid";
  return db_query($sql, [':tid' => $term->tid])->fetchField();
}

/**
 * Returns the number of answered questions for the given parliament.
 *
 * @param object $term
 *   The parliament term.
 *
 * @return int
 *   The number of answered questions.
 */
function pw_dialogues_answered_questions_by_parliament($term) {
  $q = db_select('node', 'n');
  $q->join('field_data_field_parliament', 'p', 'n.nid = p.entity_id');
  $q->join('comment', 'c', 'c.nid = n.nid');
  $q->condition('n.type', 'dialogue');
  $q->condition('n.status', NODE_PUBLISHED);
  $q->condition('p.field_parliament_tid', $term->tid);
  $q->groupBy('n.nid');

  return $q->countQuery()->execute()->fetchField();
}

/**
 * Returns number of questions by topic for the given user
 *
 * @param type $account
 *   The account object.
 *
 * @return array
 *   An associative array with topics as key and numbers as values.
 */
function pw_dialogues_topics_by_user_revision($account) {
  $q = db_select('node', 'n');
  $q->join('field_data_field_dialogue_recipient', 'r', 'n.nid = r.entity_id');
  $q->join('field_data_field_parliament', 'p', 'n.nid = p.entity_id');
  $q->join('field_data_field_dialogue_topic', 't', 'n.nid = t.entity_id');
  $q->join('taxonomy_term_data', 'td', 't.field_dialogue_topic_tid = td.tid');
  $q->addField('td', 'name');
  $q->addExpression('COUNT(n.nid)', 'count');
  $q->condition('n.type', 'dialogue');
  $q->condition('n.status', NODE_PUBLISHED);
  $q->condition('r.field_dialogue_recipient_target_id', $account->uid);
  $q->condition('p.field_parliament_tid', pw_profiles_parliament($account)->tid);
  $q->groupBy('t.field_dialogue_topic_tid');

  return $q->execute()->fetchAllKeyed();
}

/**
 * Returns number of questions by topic for the given parliament.
 *
 * @param object $term
 *   The parliament term.
 *
 * @return array
 *   An associative array with topics as key and numbers as values.
 */
function pw_dialogues_topics_by_parliament($term) {
  $q = db_select('node', 'n');
  $q->join('field_data_field_parliament', 'p', 'n.nid = p.entity_id');
  $q->join('field_data_field_dialogue_topic', 't', 'n.nid = t.entity_id');
  $q->join('taxonomy_term_data', 'td', 't.field_dialogue_topic_tid = td.tid');
  $q->addField('td', 'name');
  $q->addExpression('COUNT(n.nid)', 'count');
  $q->condition('n.type', 'dialogue');
  $q->condition('n.status', NODE_PUBLISHED);
  $q->condition('p.field_parliament_tid', $term->tid);
  $q->groupBy('t.field_dialogue_topic_tid');

  return $q->execute()->fetchAllKeyed();
}

/**
 * Returns the account version of the recipient of the question.
 *
 * @param object $node
 *   The dialogue node.
 *
 * @return object
 *   The account version.
 */
function pw_dialogues_recipient_user_revision($node) {
  $uid = $node->field_dialogue_recipient[LANGUAGE_NONE][0]['target_id'];
  $tid = $node->field_parliament[LANGUAGE_NONE][0]['tid'];

  foreach (pw_profiles_archived_revisions(user_load($uid)) as $account) {
    if ($account->field_user_parliament[LANGUAGE_NONE][0]['tid'] == $tid) {
      return user_revision_load($uid, $account->vid);
    }
  }
}

/**
 * Returns array representation of dialogue for serialization.
 *
 * @param object $node
 *   The dialogue node.
 *
 * @return array
 *   The array representation.
 */
function pw_dialogues_to_array($node) {
  if (!empty($node->field_dialogue_topic[LANGUAGE_NONE])) {
    $topic = taxonomy_term_load($node->field_dialogue_topic[LANGUAGE_NONE][0]['tid']);
  }
  $data = [
    'id' => $node->nid,
    'topic' => isset($topic) ? $topic->name : NULL,
  ];
  return $data;
}
