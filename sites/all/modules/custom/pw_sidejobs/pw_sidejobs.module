<?php
/**
 * @file
 * Code for the PW Sidejobs feature.
 */


include_once 'pw_sidejobs.features.inc';

/*
 * Implements hook_cron()
 */
function pw_sidejobs_cron(){

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sidejob')
    ->fieldCondition('field_sidejob_income_interval', 'value', '0', '>')
    ->propertyCondition('status', NODE_PUBLISHED);
  $result = $query->execute();

  if($result['node']){
    foreach(node_load_multiple(array_keys($result['node'])) as $node){
      node_save($node);
    }
  }
}

/*
 * Implements hook_node_presave()
 */
function pw_sidejobs_node_presave($node){
  if($node->type == 'sidejob'){
    pw_sidejobs_compute_total_incomes($node);
  }
}

/**
 * Implements hook_field_extra_fields().
 */
function pw_sidejobs_field_extra_fields() {
  $extra['user']['user']['display']['additional_income'] = [
    'label' => t('Additional income'),
    'description' => t(''),
    'weight' => '100',
  ];
  $extra['user']['user']['display']['sidejobs'] = [
    'label' => t('Sideline jobs'),
    'description' => t(''),
    'weight' => '100',
  ];
  return $extra;
}

/**
 * Implements hook_user_view().
 */
function pw_sidejobs_user_view($account, $view_mode, $langcode) {
  $extra = field_extra_fields_get_display('user', 'user', $view_mode);

  if (isset($extra['sidejobs'])) {
    $result = pw_sidejobs_by_user_revision_query($account)
      ->fieldOrderBy('field_sidejob_classification', 'value', 'DESC')
      ->execute();

    if (!empty($result['node'])) {
      $account->content['sidejobs'] = node_view_multiple(node_load_multiple(array_keys($result['node'])), 'embedded');
    }
  }

  if (isset($extra['additional_income']) && $extra['additional_income']['visible']) {
    $account->content['additional_income'] = pw_sidejobs_accumulated_total_income_range($account);
  }
}

/**
 * Computes total income for the given sideline job.
 *
 * The algorithm takes into account the start and end date of the sideline
 * job and the legislative period.
 *
 * @param object $node
 *   The sidejob node
 */
function pw_sidejobs_compute_total_incomes($node) {

  if ($node->type != 'sidejob') {
    return FALSE;
  }

  // Clear income fields from zero values
  if (empty($node->field_sidejob_income_min['und'][0]['value'])) {
    unset($node->field_sidejob_income_min['und'][0]);
    unset($node->field_sidejob_income_min_total['und'][0]);
  }
  if (empty($node->field_sidejob_income_max['und'][0]['value'])) {
    unset($node->field_sidejob_income_max['und'][0]);
    unset($node->field_sidejob_income_max_total['und'][0]);
  }

  $field_income_min = field_get_items('node', $node, 'field_sidejob_income_min');
  $field_income_max = field_get_items('node', $node, 'field_sidejob_income_max');
  $field_interval = field_get_items('node', $node, 'field_sidejob_income_interval');

  // If interval is set to earned once, then only set total values to their
  // related min and max values.
  if ($field_interval[0]['value'] == 0) {
    $node->field_sidejob_income_min_total['und'][0]['value'] = $field_income_min[0]['value'];
    $node->field_sidejob_income_max_total['und'][0]['value'] = $field_income_max[0]['value'];
  }
  // Otherwise try to find the beginning and ending of sidejob (or legislative
  // period or user join/retire date).
  elseif (!empty($field_income_min[0]['value']) || !empty($field_income_max[0]['value'])) {

    $date_start_latest = 0;
    $dates_start = array();
    $date_end_earlist = date('Y-m-d 00:00:00');
    $dates_end = array();

    $field_date_start = field_get_items('node', $node, 'field_sidejob_date_start');
    $field_date_end = field_get_items('node', $node, 'field_sidejob_date_end');
    if ($field_date_start !== FALSE) {
      array_push($dates_start, $field_date_start[0]['value']);
    }
    if ($field_date_end !== FALSE) {
      array_push($dates_end, $field_date_end[0]['value']);
    }

    $field_politician = field_get_items('node', $node, 'field_politician');
    $uid = $field_politician[0]['target_id'];
    if ($uid){
      $user = user_load($uid);

      $field_user_joined = field_get_items('user', $user, 'field_user_joined');
      $field_user_retired = field_get_items('user', $user, 'field_user_retired');
      if ($field_user_joined !== FALSE) {
        array_push($dates_start, $field_user_joined[0]['value']);
      }
      if ($field_user_retired !== FALSE) {
        array_push($dates_end, $field_user_retired[0]['value']);
      }

      $field_user_parliament = field_get_items('user', $user, 'field_user_parliament');
      if ($field_user_parliament) {
        $parliament = taxonomy_term_load($field_user_parliament[0]['tid']);
        $field_parliament_valid = field_get_items('taxonomy_term', $parliament, 'field_parliament_valid');
        $found_valid = FALSE;
        $parliament_latest_end_date = FALSE;
        foreach($field_parliament_valid as $parliament_valid){
          if (_pw_is_between_dates($parliament_valid)) {
            $found_valid = TRUE;
            array_push($dates_start, $parliament_valid['value']);
          }
          else {
            $parliament_latest_end_date = $parliament_valid;
          }
        }
        if (!$found_valid && $parliament_latest_end_date) {
          array_push($dates_end, $parliament_latest_end_date['value2']);
        }
      }
    }

    foreach ($dates_start as $date_start) {
      if ($date_start > $date_start_latest) {
        $date_start_latest = $date_start;
      }
    }

    foreach ($dates_end as $date_end){
      if ($date_end < $date_end_earlist) {
        $date_end_earlist = $date_end;
      }
    }

    $d1 = new DateTime($date_start_latest);
    $d2 = new DateTime($date_end_earlist);
    $datetime_diff = $d1->diff($d2);
    $multiplicator = $field_interval[0]['value'] == 12 ? $datetime_diff->y : $datetime_diff->y * 12 + $datetime_diff->m;

    // Set total incomes based on min and max incomes and the multiplicator
    // (by years or months) otherwise unset total values.
    if (!empty($field_income_min[0]['value'])) {
      $node->field_sidejob_income_min_total['und'][0]['value'] = $field_income_min[0]['value'] * $multiplicator;
    }
    else {
      unset($node->field_sidejob_income_min_total['und'][0]);
    }
    if (empty($field_income_max[0]['value'])) {
      $node->field_sidejob_income_max_total['und'][0]['value'] = $field_income_max[0]['value'] * $multiplicator;
    }
    else {
      unset($node->field_sidejob_income_max_total['und'][0]);
    }
  }
}

/**
 * Returns the total min and max income for the given sideline job.
 *
 * @param object $node
 *   The sidejob node.
 *
 * @return array
 *   The income range.
 */
function pw_sidejobs_total_income_range($node) {
  $range = [0, 0];

  $income_min_total = field_get_items('node', $node, 'field_sidejob_income_min_total');

  if (!empty($income_min_total)) {
    $range[0] = $income_min_total[0]['value'];
  }

  $income_max_total = field_get_items('node', $node, 'field_sidejob_income_max_total');

  if (!empty($income_max_total)) {
    $range[1] = $income_max_total[0]['value'];
  }

  return $range;
}

/**
 * Returns query for all sideline jobs of the given account version.
 *
 * @param object $account
 *   The user account (version).
 *
 * @return EntityFieldQuery
 *   The query object.
 */
function pw_sidejobs_by_user_revision_query($account) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'node');
  $q->entityCondition('bundle', 'sidejob');
  $q->propertyCondition('status', NODE_PUBLISHED);
  $q->fieldCondition('field_politician', 'target_id', $account->uid);
  $q->fieldCondition('field_parliament', 'tid', _pw_get_current_parliament_term()->tid);

  return $q;
}

/**
 * Returns the accumulated total min and max income from sideline jobs.
 *
 * @param object account
 *   The user entity.
 *
 * @return array
 *   The accumulated min and max income
 */
function pw_sidejobs_accumulated_total_income_range($account) {
  $initial = [0, 0];

  $result = pw_sidejobs_by_user_revision_query($account)->execute();

  if (!empty($result['node'])) {
    $nodes = node_load_multiple(array_keys($result['node']));
  }
  else {
    $nodes = [];
  }

  $callback = function ($carry, $item) {
    $range = pw_sidejobs_total_income_range($item);
    return [$carry[0] + $range[0], $carry[1] + $range[1]];
  };

  return array_reduce($nodes, $callback, $initial);
}
