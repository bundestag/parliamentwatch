<?php

/**
 * @file
 * Code for the PW Sidejobs feature.
 */

include_once 'pw_sidejobs.features.inc';

/*
 * Implements hook_cron()
 */
function pw_sidejobs_cron(){

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sidejob')
    ->fieldCondition('field_sidejob_income_interval', 'value', '0', '>')
    ->propertyCondition('status', NODE_PUBLISHED);
  $result = $query->execute();

  if($result['node']){
    foreach(node_load_multiple(array_keys($result['node'])) as $node){
      node_save($node);
    }
  }
}

/**
 * Implements hook_block_info().
 */
function pw_sidejobs_block_info() {
  $blocks['profile'] = [
    'info' => t('Sideline jobs'),
    'cache' => DRUPAL_NO_CACHE,
  ];
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function pw_sidejobs_block_view($delta = '') {
  switch ($delta) {
    case 'profile':
      return pw_sidejobs_profile_block();
    default:
      return [];
  }
}

/**
 * Displays sideline jobs section of a profile.
 */
function pw_sidejobs_profile_block() {
  $block = [];

  if (menu_get_item()['page_callback'] == 'user_revision_show') {
    $map = menu_get_item()['original_map'];
    $account = user_revision_load($map[1], $map[3]);
  }
  else {
    $account = menu_get_object('user');
  }

  if (!$account) {
    return $block;
  }

  $result = pw_sidejobs_by_user_revision_query($account)
    ->fieldOrderBy('field_sidejob_classification', 'value', 'DESC')
    ->execute();

  if (!empty($result['node'])) {
    $nodes = node_load_multiple(array_keys($result['node']));
    $block['subject'] = t('Sideline jobs');
    $block['content'] = node_view_multiple($nodes, 'embedded');
  }

  return $block;
}

/**
 * Returns all sideline jobs of the given account.
 *
 * @param object $account
 *   The user entity
 *
 * @return array
 *   The sideline jobs associated with the user entity
 */
function pw_sidejobs_load($account) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'node');
  $q->entityCondition('bundle', 'sidejob');
  $q->fieldCondition('field_politician', 'target_id', $account->uid);
  $q->propertyOrderBy('changed', 'DESC');

  $result = $q->execute();

  if (!empty($result['node'])) {
    $nodes = node_load_multiple(array_keys($result['node']));
  }
  else {
    $nodes = [];
  }

  return $nodes;
}


/**
 * Returns query for all sideline jobs of the given account version.
 *
 * @param object $account
 *   The user account (version).
 *
 * @return EntityFieldQuery
 *   The query object.
 */
function pw_sidejobs_by_user_revision_query($account) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'node');
  $q->entityCondition('bundle', 'sidejob');
  $q->propertyCondition('status', NODE_PUBLISHED);
  $q->fieldCondition('field_politician', 'target_id', $account->uid);
  $q->fieldCondition('field_parliament', 'tid', pw_profiles_parliament($account)->tid);

  return $q;
}

/**
 * Returns array of min and max income reflecting the given income classification
 *
 * @param object $node
 *   The sidejob node.
 *
 * @return array
 *   The array of min and max income and total min and max income.
 */
function pw_sidejobs_compute_incomes($node, $compute_total = TRUE) {
  $computed_income = ['min' => NULL, 'max' => NULL, 'date' => NULL];

  if ($node->type != 'sidejob') {
    return FALSE;
  }

  $field_classification = field_get_items('node', $node, 'field_sidejob_classification');
  if (intval($field_classification[0]['value']) == 0) {
    return FALSE;
  }

  // @TODO: classification for different parliaments
  switch (intval($field_classification[0]['value'])) {
    case 1:
      $computed_income['min'] = 1000;
      $computed_income['max'] = 3500;
      break;
    case 2:
      $computed_income['min'] = 3500;
      $computed_income['max'] = 7000;
      break;
    case 3:
      $computed_income['min'] = 7000;
      $computed_income['max'] = 15000;
      break;
    case 4:
      $computed_income['min'] = 15000;
      $computed_income['max'] = 30000;
      break;
    case 5:
      $computed_income['min'] = 30000;
      $computed_income['max'] = 50000;
      break;
    case 6:
      $computed_income['min'] = 50000;
      $computed_income['max'] = 75000;
      break;
    case 7:
      $computed_income['min'] = 75000;
      $computed_income['max'] = 100000;
      break;
    case 8:
      $computed_income['min'] = 100000;
      $computed_income['max'] = 150000;
      break;
    case 9:
      $computed_income['min'] = 150000;
      $computed_income['max'] = 250000;
      break;
    case 10:
      $computed_income['min'] = 250000;
      $computed_income['max'] = 250000;
      break;
  }

  $field_interval = field_get_items('node', $node, 'field_sidejob_income_interval');
  $field_date_start = field_get_items('node', $node, 'field_sidejob_date_start');
  if (intval($field_interval[0]['value']) == 0) {
    $computed_income['date'] = format_date(strtotime($field_date_start[0]['value']), 'custom', 'Y-m-d');
    return $computed_income;
  }

  $date_start_latest = FALSE;
  $dates_start = array();
  $date_end_earlist = date('Y-m-d 00:00:00');
  $dates_end = array();

  $field_date_end = field_get_items('node', $node, 'field_sidejob_date_end');
  if ($field_date_start !== FALSE) {
    array_push($dates_start, $field_date_start[0]['value']);
  }
  if ($field_date_end !== FALSE) {
    array_push($dates_end, $field_date_end[0]['value']);
  }

  $field_parliament = field_get_items('node', $node, 'field_parliament');
  if ($field_parliament) {
    $parliament = taxonomy_term_load($field_parliament[0]['tid']);
    $field_politician = field_get_items('node', $node, 'field_politician');
    if ($field_politician[0]['target_id']){

      $query = db_select('user_archive_cache', 'uac');
      $query ->fields('uac', array('uid', 'vid'))
             ->isNotNull('fraction_name');
      $date = null;
      _pw_uac_add_conditions($query, array(
          'parliament' => $parliament->name,
          'roles' => 'deputy',
          'uid' => $field_politician[0]['target_id'],
        )
      );
      $uac_result = $query->execute()->fetchAssoc();
      $user = user_revision_load($uac_result['uid'], $uac_result['vid']);

      $field_user_joined = field_get_items('user', $user, 'field_user_joined');
      $field_user_retired = field_get_items('user', $user, 'field_user_retired');
      if ($field_user_joined !== FALSE) {
        array_push($dates_start, $field_user_joined[0]['value']);
      }
      if ($field_user_retired !== FALSE) {
        array_push($dates_end, $field_user_retired[0]['value']);
      }


      $field_parliament_valid = field_get_items('taxonomy_term', $parliament, 'field_parliament_valid');
      $found_valid = FALSE;
      $parliament_latest_end_date = FALSE;
      foreach ($field_parliament_valid as $parliament_valid) {
        array_push($dates_start, $parliament_valid['value']);
        $parliament_latest_end_date = $parliament_valid;
      }
      if ($parliament_latest_end_date) {
        array_push($dates_end, $parliament_latest_end_date['value2']);
      }
    }
  }

  foreach ($dates_end as $date_end) {
    if ($date_end < $date_end_earlist) {
      $date_end_earlist = $date_end;
    }
  }

  foreach ($dates_start as $date_start) {
    if ($date_start > $date_start_latest && $date_start < $date_end_earlist) {
      $date_start_latest = $date_start;
    }
  }

  $datetime_start = new DateTime($date_start_latest);
  $datetime_end = new DateTime($date_end_earlist);
  $datetime_diff = $datetime_start->diff($datetime_end);
  $multiplicator = $field_interval[0]['value'] == 12 ? $datetime_diff->y : $datetime_diff->y * 12 + $datetime_diff->m;

  // Set total incomes based on min and max incomes and the multiplicator
  // (by years or months).
  $computed_income['total_min'] = $computed_income['min'] * $multiplicator;
  $computed_income['total_max'] = $computed_income['max'] * $multiplicator;
  $computed_income['date']['start'] = $datetime_start->format('Y-m-d');
  $computed_income['date']['end'] = $datetime_end->format('Y-m-d');

  return $computed_income;
}
