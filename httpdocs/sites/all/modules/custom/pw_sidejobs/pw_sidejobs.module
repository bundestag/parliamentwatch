<?php

/**
 * @file
 * Code for the PW Sidejobs feature.
 */

include_once 'pw_sidejobs.features.inc';

/*
 * Implements hook_cron()
 */
function pw_sidejobs_cron(){

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sidejob')
    ->fieldCondition('field_sidejob_income_interval', 'value', '0', '>')
    ->propertyCondition('status', NODE_PUBLISHED);
  $result = $query->execute();

  if($result['node']){
    foreach(node_load_multiple(array_keys($result['node'])) as $node){
      node_save($node);
    }
  }
}

/**
 * Implements hook_block_info().
 */
function pw_sidejobs_block_info() {
  $blocks['profile'] = [
    'info' => t('Sideline jobs'),
    'cache' => DRUPAL_NO_CACHE,
  ];
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function pw_sidejobs_block_view($delta = '') {
  switch ($delta) {
    case 'profile':
      return pw_sidejobs_profile_block();
    default:
      return [];
  }
}

/**
 * Displays sideline jobs section of a profile.
 */
function pw_sidejobs_profile_block() {
  $block = [];

  if (menu_get_item()['page_callback'] == 'user_revision_show') {
    $map = menu_get_item()['original_map'];
    $account = user_revision_load($map[1], $map[3]);
  }
  else {
    $account = menu_get_object('user');
  }

  if (!$account) {
    return $block;
  }

  $result = pw_sidejobs_by_user_revision_query($account)
    ->fieldOrderBy('field_sidejob_classification', 'value', 'DESC')
    ->execute();

  if (!empty($result['node'])) {
    $nodes = node_load_multiple(array_keys($result['node']));
    $block['subject'] = t('Sideline jobs');
    $block['content'] = node_view_multiple($nodes, 'embedded');
  }

  return $block;
}

/**
 * Returns all sideline jobs of the given account.
 *
 * @param object $account
 *   The user entity
 *
 * @return array
 *   The sideline jobs associated with the user entity
 */
function pw_sidejobs_load($account) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'node');
  $q->entityCondition('bundle', 'sidejob');
  $q->fieldCondition('field_politician', 'target_id', $account->uid);
  $q->propertyOrderBy('changed', 'DESC');

  $result = $q->execute();

  if (!empty($result['node'])) {
    $nodes = node_load_multiple(array_keys($result['node']));
  }
  else {
    $nodes = [];
  }

  return $nodes;
}


/**
 * Returns query for all sideline jobs of the given account version.
 *
 * @param object $account
 *   The user account (version).
 *
 * @return EntityFieldQuery
 *   The query object.
 */
function pw_sidejobs_by_user_revision_query($account) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'node');
  $q->entityCondition('bundle', 'sidejob');
  $q->propertyCondition('status', NODE_PUBLISHED);
  $q->fieldCondition('field_politician', 'target_id', $account->uid);
  $q->fieldCondition('field_parliament', 'tid', pw_profiles_parliament($account)->tid);

  return $q;
}

/**
 * Returns the interval at which the income for the given sidejob is received.
 *
 * @param $node
 *   The node of type sidejob.
 *
 * @return int
 *   The interval at which the income is received.
 */
function pw_sidejobs_interval($node) {
  $items = field_get_items('node', $node, 'field_sidejob_income_interval');

  if ($items) {
    $interval = $items[0]['value'];
  }
  else {
    $interval = 0;
  }

  return $interval;
}

/**
 * Returns the classification of the given sideline job.
 *
 * @param $node
 *   The node of type sidejob.
 *
 * @return int
 *   The classification.
 */
function pw_sidejobs_classification($node) {
  $items = field_get_items('node', $node, 'field_sidejob_classification');

  if ($items) {
    $classification = $items[0]['value'];
  }
  else {
    $classification = 0;
  }

  return $classification;
}

/**
 * Returns the range of income accumulated with the given sideline job.
 *
 * If the income range cannot be computed an empty array is returned.
 *
 * @param $node
 *   The node of type sidejob.
 *
 * @return array
 *   An array with the minimum and maximum income.
 */
function pw_sidejobs_income_range($node) {
  $income_range = pw_sidejobs_base_income_range(pw_sidejobs_classification($node));
  $multiplier = pw_sidejobs_multiplier(pw_sidejobs_interval($node), pw_sidejobs_datetime_range($node));
  return array_filter(array_map(function ($value) use ($multiplier) { return $value * $multiplier; }, $income_range));
}

/**
 * Returns the income range for the given classification of a sideline job.
 *
 * @param int $classification
 *   The classification of a sideline job.
 *
 * @return array
 *   An array with the minimum and maximum income.
 */
function pw_sidejobs_base_income_range($classification) {
  switch ($classification) {
    case 1:
      return [1000, 3500];
    case 2:
      return [3500, 7000];
    case 3:
      return [7000, 15000];
    case 4:
      return [15000, 30000];
    case 5:
      return [30000, 50000];
    case 6:
      return [50000, 75000];
    case 7:
      return [75000, 100000];
    case 8:
      return [100000, 150000];
    case 9:
      return [150000, 250000];
    case 10:
      return [250000, 250000];
    default:
      return [];
  }
}

/**
 * Returns the applicable start and end date for the given sideline job.
 *
 * @param $node
 *   The node of type sidejob.
 *
 * @return DateTime[]
 *   An array with the start and end date.
 */
function pw_sidejobs_datetime_range($node) {
  $dates_start = [];
  $dates_end = [date('Y-m-d 00:00:00')];

  $field_parliament_valid = field_get_items('taxonomy_term', pw_globals_parliament($node), 'field_parliament_valid');
  array_push($dates_start, end($field_parliament_valid)['value']);
  array_push($dates_end, end($field_parliament_valid)['value2']);

  $field_date_start = field_get_items('node', $node, 'field_sidejob_date_start');
  if ($field_date_start !== FALSE) {
    array_push($dates_start, $field_date_start[0]['value']);
  }

  $field_date_end = field_get_items('node', $node, 'field_sidejob_date_end');
  if ($field_date_end !== FALSE) {
    array_push($dates_end, $field_date_end[0]['value']);
  }

  $politician = pw_globals_politician($node);

  $field_user_joined = field_get_items('user', $politician, 'field_user_joined');
  if ($field_user_joined !== FALSE) {
    array_push($dates_start, $field_user_joined[0]['value']);
  }

  $field_user_retired = field_get_items('user', $politician, 'field_user_retired');
  if ($field_user_retired !== FALSE) {
    array_push($dates_end, $field_user_retired[0]['value']);
  }

  $date[] = new DateTime(max(array_filter($dates_start)));

  if (pw_sidejobs_interval($node) > 0) {
    $date[] = new DateTime(min(array_filter($dates_end)));
  }

  return $date;
}

/**
 * Returns the multiplier for the given sideline job.
 *
 * This number is used to calculate the accumulated income for the applicable
 * date range.
 *
 * @param $node
 *   The node of type sidejob.
 *
 * @return int
 *   The multiplier.
 */
function pw_sidejobs_multiplier($interval, $datetime_range) {
  if ($interval == 0) {
    return 1;
  }

  if ($datetime_range[0] > $datetime_range[1]) {
    return 0;
  }

  $datetime_diff = $datetime_range[0]->diff($datetime_range[1]);

  if ($interval == 12) {
    $multiplier = $datetime_diff->y;
  }
  else {
    $multiplier = $datetime_diff->y * 12 + $datetime_diff->m;
  }

  return (int) $multiplier;
}

/**
 * Returns array of min and max income reflecting the given income classification
 *
 * @param object $node
 *   The sidejob node.
 *
 * @return array
 *   The array of min and max income and total min and max income.
 */
function pw_sidejobs_compute_incomes($node) {
  $computed_income = ['min' => NULL, 'max' => NULL, 'date' => NULL];

  if ($node->type != 'sidejob') {
    return FALSE;
  }

  $computed_income = pw_sidejobs_base_income_range($node);

  if (empty($computed_income)) {
    return FALSE;
  }

  $field_interval = field_get_items('node', $node, 'field_sidejob_income_interval');
  $field_date_start = field_get_items('node', $node, 'field_sidejob_date_start');
  if (intval($field_interval[0]['value']) == 0) {
    $computed_income['date'] = format_date(strtotime($field_date_start[0]['value']), 'custom', 'Y-m-d');
    return $computed_income;
  }

  $date_start_latest = FALSE;
  $dates_start = array();
  $date_end_earlist = date('Y-m-d 00:00:00');
  $dates_end = array();

  $field_date_end = field_get_items('node', $node, 'field_sidejob_date_end');
  if ($field_date_start !== FALSE) {
    array_push($dates_start, $field_date_start[0]['value']);
  }
  if ($field_date_end !== FALSE) {
    array_push($dates_end, $field_date_end[0]['value']);
  }

  $field_parliament = field_get_items('node', $node, 'field_parliament');
  if ($field_parliament) {
    $parliament = taxonomy_term_load($field_parliament[0]['tid']);
    $field_politician = field_get_items('node', $node, 'field_politician');
    if ($field_politician[0]['target_id']){

      $query = db_select('user_archive_cache', 'uac');
      $query ->fields('uac', array('uid', 'vid'))
             ->isNotNull('fraction_name');
      $date = null;
      _pw_uac_add_conditions($query, array(
          'parliament' => $parliament->name,
          'roles' => 'deputy',
          'uid' => $field_politician[0]['target_id'],
        )
      );
      $uac_result = $query->execute()->fetchAssoc();
      $user = user_revision_load($uac_result['uid'], $uac_result['vid']);

      $field_user_joined = field_get_items('user', $user, 'field_user_joined');
      $field_user_retired = field_get_items('user', $user, 'field_user_retired');
      if ($field_user_joined !== FALSE) {
        array_push($dates_start, $field_user_joined[0]['value']);
      }
      if ($field_user_retired !== FALSE) {
        array_push($dates_end, $field_user_retired[0]['value']);
      }


      $field_parliament_valid = field_get_items('taxonomy_term', $parliament, 'field_parliament_valid');
      $parliament_latest_end_date = FALSE;
      foreach ($field_parliament_valid as $parliament_valid) {
        array_push($dates_start, $parliament_valid['value']);
        $parliament_latest_end_date = $parliament_valid;
      }
      if ($parliament_latest_end_date) {
        array_push($dates_end, $parliament_latest_end_date['value2']);
      }
    }
  }

  foreach ($dates_end as $date_end) {
    if ($date_end < $date_end_earlist) {
      $date_end_earlist = $date_end;
    }
  }

  foreach ($dates_start as $date_start) {
    if ($date_start > $date_start_latest && $date_start < $date_end_earlist) {
      $date_start_latest = $date_start;
    }
  }

  $datetime_start = new DateTime($date_start_latest);
  $datetime_end = new DateTime($date_end_earlist);
  $datetime_diff = $datetime_start->diff($datetime_end);
  $multiplicator = $field_interval[0]['value'] == 12 ? $datetime_diff->y : $datetime_diff->y * 12 + $datetime_diff->m;

  // Set total incomes based on min and max incomes and the multiplicator
  // (by years or months).
  $computed_income['total_min'] = $computed_income['min'] * $multiplicator;
  $computed_income['total_max'] = $computed_income['max'] * $multiplicator;
  $computed_income['date']['start'] = $datetime_start->format('Y-m-d');
  $computed_income['date']['end'] = $datetime_end->format('Y-m-d');

  return $computed_income;
}
