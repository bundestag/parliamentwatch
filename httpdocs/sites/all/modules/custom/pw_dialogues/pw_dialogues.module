<?php

/**
 * @file
 * Module for the dialogue import.
 */
include_once 'pw_dialogues.features.inc';

/**
 * A buffer of overlap between the imports in seconds.
 */
define('PW_DIALOGUES_INTERVAL', 86400); // one day buffer

/**
 * Implements hook_menu().
 */
function pw_dialogues_menu() {
  $items['dialogues'] = [
    'page callback' => 'pw_dialogues_post',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  ];
  $items['dialogues/%taxonomy_term/%'] = [
    'title callback' => 'pw_dialogues_page_title',
    'title arguments' => [1, 2],
    'page callback' => 'pw_dialogues_page',
    'page arguments' => [1, 2],
    'access arguments' => ['access content'],
    'type' => MENU_CALLBACK,
  ];
  $items['dialogues/%taxonomy_term/%/%'] = [
    'title callback' => 'pw_dialogues_page_title',
    'title arguments' => [1, 2, 3],
    'page arguments' => [1, 2, 3],
    'access arguments' => ['access content'],
    'type' => MENU_CALLBACK,
  ];
  $items['admin/config/pw/dialogues/settings'] = [
    'title' => 'Dialogue importer',
    'description' => 'Configure the source URL for the dialogue importer.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pw_dialogues_admin_settings_form'),
    'access arguments' => array('import dialogue_importer feeds'),
    'file' => 'pw_dialogues.admin.inc',
  ];
  $items['admin/config/pw/dialogues'] = [
    'title' => 'Dialogue importer',
    'description' => 'Mass re-import dialogues.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pw_dialogues_admin_reimport'),
    'access arguments' => array('import dialogue_importer feeds'),
    'file' => 'pw_dialogues.admin.inc',
  ];
  $items['api/import/dialogue/%'] = [
    'title' => 'imports dialogue',
    'access arguments' => array('access content'),
    'page callback' => 'pw_dialogues_triggered_import',
    'type' => MENU_SUGGESTED_ITEM,
  ];
  return $items;
}

/**
 * Implements hook_page_delivery_callback_alter().
 *
 * In order to ensure caching mechanisms store a distinct copy for AJAX
 * responses the parameter ajax needs to be present. For caches evaluating Vary
 * headers one would usually add Vary: X-Requested-With to the HTTP headers.
 * Drupal's internal page cache uses only the request URI as an identifier
 * though.
 */
function pw_dialogues_page_delivery_callback_alter(&$callback) {
  if (!isset(drupal_get_query_parameters()['ajax'])) {
    return;
  }

  if (menu_get_item()['page_callback'] != 'pw_dialogues_page') {
    return;
  }

  // jQuery sets a HTTP_X_REQUESTED_WITH header of 'XMLHttpRequest'.
  // If a page would normally be delivered as an html page, and it is called
  // from jQuery, deliver it instead as an Ajax response.
  if (isset($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest' && $callback == 'drupal_deliver_html_page') {
    $callback = 'pw_globals_deliver_ajax_page';
  }
}

/**
 * Implements hook_token_info_alter().
 */
function pw_dialogues_token_info_alter(&$data) {
  $data['tokens']['user']['questions-and-answers'] = [
    'name' => t('Questions and answers'),
    'description' => t('The number of questions and answers for the user account.'),
  ];
}

/**
 * Implements hook_tokens().
 */
function pw_dialogues_tokens($type, $tokens, array $data = [], array $options = []) {
  $replacements = [];
  $sanitize = !empty($options['sanitize']);

  if ($type == 'user' && !empty($data['user'])) {
    $account = $data['user'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'questions-and-answers':
          $args = [
            '@answers' => $account->number_of_answers,
            '@questions' => $account->number_of_questions,
          ];
          $replacements[$original] = t('answered @answers of @questions questions', $args);
      }
    }
  }

  return $replacements;
}

/**
 * Implements hook_block_info().
 */
function pw_dialogues_block_info() {
  $blocks['profile'] = [
    'info' => t('Questions and answers'),
    'cache' => DRUPAL_NO_CACHE,
  ];
  $blocks['recent'] = [
    'info' => t('Recent questions and answers (in parliament)'),
    'cache' => DRUPAL_NO_CACHE,
  ];
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function pw_dialogues_block_view($delta) {
  switch ($delta) {
    case 'profile':
      return pw_dialogues_profile_block();
    case 'recent':
      return pw_dialogues_recent_block();
  }
}

/**
 * Implements hook_block_view_MODULE_DELTA_alter().
 */
function pw_dialogues_block_view_pw_globals_title_alter(&$data, $block) {
  if (menu_get_item()['path'] == 'dialogues/%/%/%') {
    $parliament = menu_get_object('taxonomy_term');
    $uid = menu_get_item()['map'][3];
    $role = (menu_get_item()['map'][2] == 'candidates') ? 'candidate' : 'deputy';
    $account = user_revision_load($uid, pw_userarchives_find_revision($uid, $parliament, $role));
    $data['content'] = [
      '#account' => $account,
      '#markup' => $data['content'],
      '#parliament' => $parliament,
    ];
  }
}

/**
 * Implements hook_cron().
 *
 * Imports all dialogues once at night. Normally all dialogues should be
 * already imported by push request to api/import/dialogue/% via the moderation
 * backend.
 */
function pw_dialogues_cron() {

  // get import base url
  if ($source = variable_get('pw_dialogues_importer_source')) {

    // append the updated_since GET parameter to the source URL.
    if ($last_import = variable_get('pw_dialogues_importer_last_import', 0)) {

      // import only every X days / hours/ etc
      if ($last_import < time() - PW_DIALOGUES_INTERVAL) {

        // import buffer: 1.5 of import interval
        $updated_since_timestamp = $last_import - PW_DIALOGUES_INTERVAL * 1.5;
        $updated_since = date('Y-m-d\\TH:i:s', $updated_since_timestamp);
        if (strpos($source, '?') === FALSE) {
          $source .= '?updated_since=' . $updated_since;
        }
        else {
          $source .= '&updated_since=' . $updated_since;
        }

        // do the import
        pw_dialogues_do_import_questions($source);
        pw_dialogues_do_import_answers($source);

        // trigger userarchive cron which
        if (function_exists('pw_userarchives_cron')) {

          // query which politicians have a changed question and answer count.
          $users = db_query('SELECT DISTINCT f.field_dialogue_recipient_target_id
            FROM {field_data_field_dialogue_recipient} AS f
            INNER JOIN {feeds_item} AS i ON f.entity_type = i.entity_type AND f.entity_id = i.entity_id
            WHERE i.imported >= :imported', array(':imported' => $updated_since_timestamp))->fetchCol();

          // rewrite user archive cache table
          foreach ($users as $uid) {
            pw_userarchives_cron($uid);
          }
        }

        // save last import date
        variable_set('pw_dialogues_importer_last_import', REQUEST_TIME);
      }
    }
  }
}

/**
 * Implements hook_node_view().
 */
function pw_dialogues_node_view($node, $view_mode) {
  if ($node->type != 'dialogue') {
    return;
  }

  $recipient = pw_dialogues_recipient_user_revision($node);
  $node->content['user_display_name'] = _pw_get_fullname($recipient);
  $node->content['user_picture'] = field_view_field('user', $recipient, 'field_user_picture', ['label' => 'hidden', 'settings' => ['image_style' => 'square_small']]);
  $node->content['user_party'] = field_view_field('user', $recipient, 'field_user_party', ['label' => 'hidden', 'type' => 'taxonomy_term_reference_plain']);
  $node->content['user_url'] = url(entity_uri('user', $recipient)['path']);

  $comments = pw_dialogues_answers($node);

  if ($comments) {
    if ($view_mode == 'full') {
      $node->content['answers'] = comment_view_multiple($comments, $node, $view_mode);
    }
    else {
      $node->content['answers'] = comment_view_multiple(array_slice($comments, 0, 1, TRUE), $node, $view_mode);
    }
  }

  if (node_is_page($node)) {
    $parliament_tid = $node->field_parliament[LANGUAGE_NONE][0]['tid'];
    if ($node->field_dialogue_before_election[LANGUAGE_NONE][0]['value']) {
      menu_tree_set_path('main-menu', "profiles/$parliament_tid/candidates");
    }
    else {
      menu_tree_set_path('main-menu', "profiles/$parliament_tid/deputies");
    }
  }
}

/**
 * Implements hook_entity_presave().
 *
 * Modifies data on dialogue save (or import via api).
 */
function pw_dialogues_entity_presave($entity, $type) {

  // Force URL alias for dialogues
  if ($type == 'node' && $entity->type == 'dialogue' && isset($entity->nid)) {
    module_load_include('inc', 'pathauto');
    $entity->path['pathauto'] = TRUE;
    $alias_action = variable_get('pathauto_update_action', 0);
    variable_set('pathauto_update_action', PATHAUTO_UPDATE_ACTION_DELETE);
    $entity->path = pathauto_node_update_alias($entity, 'update');
    variable_set('pathauto_update_action', $alias_action);
  }
}

/**
 * Implements hook_webform_submission_insert().
 */
function pw_dialogues_webform_submission_insert($node, $submission) {
  if ($submission->nid == 10446 && variable_get('pw_modtool_api_queue_run', FALSE)){ // node id of question form
    $queue = DrupalQueue::get('pw_dialogues_questions', TRUE);
    $payload = array(
      'type' => "question",
      'recipient_id_e' => TRUE,
      'recipient_id' => $submission->data[18][0],
      'text' => $submission->data[25][0],
      'topic' => $submission->data[12][0],
      'summary' => null,
      'context' => $submission->data[19][0],
      'sender_first_name' => $submission->data[8][0],
      'sender_last_name' => $submission->data[9][0],
      'sender_email' => $submission->data[7][0],
      'sender_city' => $submission->data[10][0],
      'sender_ip' => $submission->remote_addr,
      'inserted_date' => date('Y-m-d\TH:i:s', $submission->submitted)
    );
    $queue->createItem($payload);
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function pw_dialogues_cron_queue_info() {
  if (variable_get('pw_modtool_api_queue_run', FALSE)) {
    $queues['pw_dialogues_questions'] = array(
      'worker callback' => '_pw_dialogues_questions_queue_worker',
      'time' => variable_get('pw_modtool_api_queue_run_time', 60),
      'skip on cron' => variable_get('pw_modtool_api_skip_on_cron', TRUE)
    );
  }
  return $queues;
}

/**
 * Implements worker callback
 * Throws exception upon unsuccessful delivery
 */
function _pw_dialogues_questions_queue_worker($payload) {
  $payload['auth_token'] = variable_get('pw_modtool_api_auth_token');
  $endpoint = variable_get('pw_modtool_api_question_endpoint');
  $basic_auth = variable_get('pw_modtool_api_basic_auth', FALSE);
  $curl = curl_init($endpoint);
  curl_setopt($curl, CURLOPT_POSTFIELDS, json_encode($payload));
  curl_setopt($curl, CURLOPT_HTTPHEADER, array('Content-Type:application/json'));
  if ($basic_auth){
    curl_setopt($curl, CURLOPT_USERPWD, $basic_auth);
  }
  curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
  $response = curl_exec($curl);
  $response_info = curl_getinfo($curl);
  curl_close($curl);
  if ($response_info['http_code'] != 200) {
    throw new Exception('Modtool API responded with a return code of ' . $response_info['http_code'] . '. The response body is: ' . $response);
  }
}

/**
 * Implements hook_feeds_presave().
 */
function pw_dialogues_feeds_presave(FeedsSource $source, $entity, $item) {

  if ($source->id == 'dialogue_importer' || $source->id == 'dialogue_message_importer') {

    // delete and skip item instead of importing
    if (!$entity->status) {

      // skip item
      $entity->feeds_item->skip = TRUE;

      // delete dialogue node (question)
      if ($entity->nid && !isset($entity->cid)) {
        entity_delete("node", $entity->nid);
      }

      // delete dialogue comments (answers)
      elseif ($entity->cid) {
        entity_delete("comment", $entity->cid);
      }
    }

    // remove empty attachments
    elseif (isset($entity->field_dialogue_documents['und'][0]['url']) && empty($entity->field_dialogue_documents['und'][0]['url'])) {
      $entity->field_dialogue_documents = NULL;
    }
    else {

      // add title to link
      foreach ($entity->field_dialogue_documents['und'] as &$document) {
        $document['title'] = basename($document['url']);
      }
    }
  }
}

/**
 * Implements hook_theme().
 */
function pw_dialogues_theme() {
  return [
    'dialogues_stats' => [
      'variables' => [
        'questions' => NULL,
        'answers' => NULL,
        'answer_ratio' => NULL,
        'answer_ratio_by_party' => NULL,
        'average_response_time' => NULL,
        'before_election' => NULL,
      ],
      'template' => 'dialogues-stats',
    ],
    'dialogue_search_summary' => [
      'variables' => [
        'response' => NULL,
        'filters' => NULL,
      ],
    ],
  ];
}

/**
 * Implements hook_query_TAG_alter().
 */
function pw_dialogues_query_ignore_standard_replies_alter(QueryAlterableInterface $query) {
  $query->join('field_data_field_dialogue_is_standard_reply', 's', 'c.cid = s.entity_id');
  $query->condition('s.field_dialogue_is_standard_reply_value', 0);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function pw_dialogues_form_pw_dialogues_filters_form_alter(&$form, &$form_state) {
  $form['form_build_id']['#access'] = FALSE;
  $form['form_token']['#access'] = FALSE;
  $form['form_id']['#access'] = FALSE;
}

/**
 * Page callback: creates or updates a dialogue node and its comments.
 */
function pw_dialogues_post() {
  if (!empty($_SERVER['REDIRECT_HTTP_AUTHORIZATION'])) {
    $credentials = base64_decode(substr($_SERVER['REDIRECT_HTTP_AUTHORIZATION'], 6));
    list($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']) = explode(':', $credentials, 2);
  }

  if (!isset($_SERVER['PHP_AUTH_USER']) || !isset($_SERVER['PHP_AUTH_PW'])) {
    drupal_add_http_header('Status', '401 Unauthorized');
    return;
  }

  $uid = user_authenticate($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']);

  if (!$uid) {
    drupal_add_http_header('Status', '401 Unauthorized');
    return;
  }

  $GLOBALS['user'] = user_load($uid);

  if (!in_array(user_role_load_by_name('API User')->rid, array_keys($GLOBALS['user']->roles))) {
    drupal_add_http_header('Status', '403 Forbidden');
    return;
  }

  if ($_SERVER['REQUEST_METHOD'] != 'POST') {
    drupal_add_http_header('Status', '405 Method Not Allowed');
    drupal_add_http_header('Allow', 'POST');
    return;
  }

  if ($_SERVER['CONTENT_TYPE'] != 'text/xml') {
    drupal_add_http_header('Status', '415 Unsupported Media Type');
    return;
  }

  $doc = new DOMDocument('1.0');

  if (!$doc->load('php://input')) {
    drupal_add_http_header('Status', '400 Bad Request');
    return;
  }

  try {
    $node = _pw_dialogues_question($doc);
    $comments = _pw_dialogues_answers($doc, $node);
  }
  catch (Exception $e) {
    watchdog_exception('pw_dialogues', $e);
    drupal_add_http_header('Status', '422 Unprocessable Entity');
    return;
  }

  $is_new = empty($node->nid);

  node_save($node);
  foreach ($comments as $comment) {
    comment_save($comment);
  }

  if ($is_new) {
    drupal_add_http_header('Status', '201 Created');
    drupal_add_http_header('Location', url(node_uri($node)['path'], ['absolute' => TRUE]));
  }
  else {
    drupal_add_http_header('Status', '303 See Other');
    drupal_add_http_header('Location', url(node_uri($node)['path'], ['absolute' => TRUE]));
  }
}

/**
 * Title callback: Sets the title for the dialogues page.
 */
function pw_dialogues_page_title($parliament_term, $role_name, $uid = NULL) {
  if (isset($uid)) {
    return t('Questions to @name', ['@name' => _pw_get_fullname(user_load($uid))]);
  }
  elseif ($role_name == 'deputies') {
    return t('Questions to deputies in @parliament', ['@parliament' => $parliament_term->name]);
  }
  elseif ($role_name == 'candidates') {
    return t('Questions to candidates in @parliament', ['@parliament' => $parliament_term->name]);
  }
}

/**
 * Page callback: Displays questions and answers for the given parliament.
 */
function pw_dialogues_page($parliament_term, $role_name, $uid = NULL) {
  if (!in_array($role_name, ['candidates', 'deputies'])) {
    return MENU_NOT_FOUND;
  }

  $limit = 12;
  $filters = _pw_dialogues_sanitized_filters(drupal_get_query_parameters());
  $q = pw_dialogues_base_search_query($parliament_term, $role_name);

  if (isset($uid)) {
    $q->condition('field_dialogue_recipient', $uid);
  }

  if (isset($filters['topic'])) {
    $f = new SearchApiQueryFilter('OR', ['facet:field_dialogue_topic']);
    foreach ($filters['topic'] as $party) {
      $f->condition('field_dialogue_topic', $party);
    }
    $q->filter($f);
  }

  if (isset($filters['date'])) {
    $q->condition('created', $filters['date'][0], '>=');
    $q->condition('created', $filters['date'][1], '<');
  }

  if (isset($filters['has-reply'])) {
    $q->condition('comment_count', 0, '>');
  }

  if (isset($filters['ignore-standard-replies'])) {
    $q->condition('comments:field_dialogue_is_standard_reply', FALSE);
  }

  if (isset($filters['keys'])) {
    $q->keys($filters['keys']);
  }

  $response = $q
    ->sort('created', 'DESC')
    ->range(pager_find_page() * $limit, $limit)
    ->execute();

  pager_default_initialize($response['result count'], $limit);

  $build = node_view_multiple(node_load_multiple(array_keys($response['results'])), 'tile');
  $build['nodes']['#theme_wrappers'] = ['container__tiles'];
  $build['nodes']['#sorted'] = FALSE;
  $build['nodes']['summary'] = [
    '#theme' => 'dialogue_search_summary',
    '#response' => $response,
    '#filters' => $filters,
    '#weight' => -1,
  ];
  $build['nodes']['pager'] = [
    '#theme' => 'pager',
    '#weight' => $limit,
  ];
  $build['filters'] = drupal_get_form('pw_dialogues_filters_form', $response['search_api_facets']);
  $build['filters']['#theme_wrappers'][] = 'container__filterbar';
  $build['filters']['#weight'] = -5;
  $build['#theme_wrappers'] = ['container'];
  $build['#attributes'] = ['id' => 'ajax'];

  return $build;
}

/**
 * Page callback: Imports questions.
 */
function pw_dialogues_triggered_import() {
  drupal_add_http_header('Content-type', 'text/plain; charset=utf8');
  $debug_message = array();
  $debug_message['request_uri'] = request_uri();
  $return_value = 'FAILED';
  if (is_numeric(arg(3))) {

    // prepare for import
    $dialogue_id = arg(3);
    $source = variable_get('pw_dialogues_importer_source');
    $source .= $dialogue_id;
    $source .= '?unreleased=1';
    $debug_message['source'] = $source;

    // retrieve what to do (delete, create, ...)
    $doc = new DOMDocument();
    $doc->preserveWhiteSpace = false;
    $doc->load($source);
    $xpath = new DOMXpath($doc);
    $xlist_status = $xpath->query("//message[type='question']/status");
    $xnode_status = $xlist_status->item(0)->nodeValue;

    // do import
    pw_dialogues_do_import_questions($source);

    // check if dialogue was imported
    $efq_nodes = new EntityFieldQuery();
    $efq_nodes->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'dialogue')
      ->fieldCondition('field_dialogue_id', 'value', $dialogue_id);
    $result = $efq_nodes->execute();
    $debug_message['result'] = $result;

    // dialogue found
    if (isset($result['node'])) {
      $dialogue_nid = key($result['node']);
      $node = node_load($dialogue_nid);
      $recipient_id = $node->field_dialogue_recipient['und'][0]['target_id'];

      // delete answers and re-import them
      /* $sql = "SELECT cid FROM {comment} WHERE nid=:nid";
        $cids_to_delete = db_query($sql, array(':nid' => $dialogue_nid))->fetchCol();
        $debug_message['cids_to_delete'] = $cids_to_delete;
        comment_delete_multiple($cids_to_delete); */
      pw_dialogues_do_import_answers($source);

      // set return_value to OK
      if (is_numeric($recipient_id) && ($user = user_load($recipient_id)) || $node->status != 1) {
        $return_value = 'OK';
        if (function_exists('pw_userarchives_cron')) {
          pw_userarchives_cron($recipient_id);
        }
      }
    }

    // node deleted
    elseif ($xnode_status != 1 && !isset($result['node'])) {
      $return_value = 'OK';
    }
  }

  _pw_send_debug_mail('Import ' . $return_value . ': ' . request_uri(), $debug_message);
  print $return_value;
}

/**
 * Form constructor for the profile filters form.
 */
function pw_dialogues_filters_form($form, &$form_state, $facets) {
  $parameters = drupal_get_query_parameters();
  $topic_values = _pw_profiles_facet_values($facets['field_dialogue_topic']);

  $form['#method'] = 'get';
  $form['#action'] = url(current_path());
  $form['#attributes']['data-ajax-target'] = '#ajax';
  $form['#theme'] = 'filterbar';
  $form['keys'] = [
    '#type' => 'textfield',
    '#title' => t('Search'),
    '#title_display' => 'invisible',
    '#default_value' => isset($parameters['keys']) ? $parameters['keys'] : '',
    '#attributes' => ['placeholder' => t('Search')],
  ];

  if (count($topic_values) > 1) {
    $form['topic'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Filter by topic'),
      '#title_display' => 'invisible',
      '#options' => _pw_dialogues_options($topic_values),
      '#multiple' => TRUE,
      '#default_value' => empty($parameters['topic']) ? [] : $parameters['topic'],
      '#dropdown' => TRUE,
    );
  }

  $form['date'] = [
    '#type' => 'interval',
    '#title' => t('Filter by date'),
    '#title_display' => 'invisible',
    '#default_value' => empty($parameters['date']) ? [] : $parameters['date'],
    '#attributes' => ['type' => 'date', 'placeholder' => t('yyyy-mm-dd')],
    '#dropdown' => TRUE,
  ];

  $form['has-reply'] = [
    '#type' => 'checkbox',
    '#title' => t('Has reply'),
    '#default_value' => isset($parameters['has-reply']) ? 1 : 0,
  ];

  if (isset($parameters['has-reply'])) {
    $form['ignore-standard-replies'] = [
      '#type' => 'checkbox',
      '#title' => t('Ignore standard replies'),
      '#default_value' => isset($parameters['ignore-standard-replies']) ? 1 : 0,
    ];
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Filter profiles'),
  );

  return $form;
}

/**
 * Displays the questions and answers section of a profile.
 *
 * @return array
 *   The block render array.
 */
function pw_dialogues_profile_block() {
  $block = [];

  if (menu_get_item()['page_callback'] == 'user_revision_show') {
    $map = menu_get_item()['original_map'];
    $account = user_revision_load($map[1], $map[3]);
  }
  else {
    $account = menu_get_object('user');
  }

  if (!$account || !_pw_user_has_role($account, 'Politician')) {
    return $block;
  }

  $block['subject'] = t('Questions and Answers');
  $result = pw_dialogues_by_user_revision_query($account)->propertyOrderBy('created', 'DESC')->execute();

  if (!empty($result['node'])) {
    $nodes = node_load_multiple(array_keys($result['node']));
    $inline_js = 'window.dialogues = ' . drupal_json_encode(pw_dialogues_topics_by_user_revision($account));
    $block['content'] = node_view_multiple(array_slice($nodes, 0, 12, TRUE), 'embedded');
    $block['content']['nodes']['#theme_wrappers'] = ['container__swiper'];
    $block['content']['stats'] = [
      '#theme' => 'dialogues_stats',
      '#questions' => $account->number_of_questions,
      '#answers' => $account->number_of_answers,
      '#answer_ratio' => round(100 * $account->number_of_answers / $account->number_of_questions, 0),
      '#average_response_time' => round(pw_dialogues_average_response_time_by_account($account) / 86400),
    ];
    $block['content']['stats']['#attached']['js'][$inline_js] = [
      'scope' => 'footer',
      'type' => 'inline',
    ];
    if (_pw_user_has_role($account, 'Candidate')) {
      $role_name = 'candidates';
    } else {
      $role_name = 'deputies';
    }
    $block['overview_url'] = url('dialogues/' . pw_profiles_parliament($account)->tid . '/' . $role_name . '/' . $account->uid);
  }
  $block['content']['question_form'] = node_view(node_load(10446), 'form');

  return $block;
}

/**
 * Displays the questions and answers section of a profile.
 *
 * @return array
 *   The block render array.
 */
function pw_dialogues_recent_block() {
  $block = [
    'subject' => t('Questions and answers'),
  ];
  $term = menu_get_object('taxonomy_term', 2);

  if (!$term || $term->vocabulary_machine_name != 'parliaments') {
    return $block;
  }

  $server = search_api_index_load('node_index')->server();
  $excerpt = $server->options['excerpt'];
  $retrieve_data = $server->options['retrieve_data'];

  // Temporarily override options to avoid performance and memory problems.
  $server->options['excerpt'] = FALSE;
  $server->options['retrieve_data'] = FALSE;

  $response = pw_dialogues_by_parliament_query($term)
    ->condition('comment_count', 0, '>')
    ->sort('created', 'DESC')
    ->range(0, 4)
    ->execute();

  if ($response['result count'] > 0) {
    $today = new DateTime();
    $election_date = pw_parliaments_election_date($term);
    $before_election = ($today < $election_date) ? 1 : 0;

    $nodes = node_load_multiple(array_keys($response['results']));
    $inline_js = 'window.dialogues = ' . drupal_json_encode(pw_dialogues_topics_by_parliament($term)) . ';';
    $questions = pw_dialogues_by_parliament_query($term)->execute()['result count'];
    $answers = pw_dialogues_answered_questions_by_parliament($term);
    $block['content'] = node_view_multiple($nodes, 'tile');
    $block['content']['stats'] = [
      '#theme' => 'dialogues_stats',
      '#questions' => $questions,
      '#answers' => $answers,
      '#answer_ratio' => round(100 * $answers / $questions, 0),
      '#answer_ratio_by_party' => pw_dialogues_party_ratios_by_parliament($term),
      '#average_response_time' => round(pw_dialogues_average_response_time_by_parliament($term) / 86400),
      '#before_election' => $before_election,
      '#weight' => -5,
    ];
    $block['content']['stats']['#attached']['js'][$inline_js] = [
      'scope' => 'footer',
      'type' => 'inline',
    ];
  }

  // Restore original solr server options.
  $server->options['excerpt'] = $excerpt;
  $server->options['retrieve_data'] = $retrieve_data;

  return $block;
}

/**
 * Import dialogues (questions) from the given source.
 *
 * @param string $source
 *   The URL of the mod-tool.
 *
 * @return boolean
 */
function pw_dialogues_do_import_questions($source) {
  $dialogue_feed = feeds_source('dialogue_importer');
  $dialogue_feed->addConfig(array(
    'FeedsHTTPFetcher' => array(
      'source' => $source,
    ),
  ));
  while (FEEDS_BATCH_COMPLETE != $dialogue_feed->import()) {
    ;
  }

  watchdog('dialogue_importer', 'questions imported from @source', ['@source' => $source]);

  return TRUE;
}

/**
 * Imports answers from the given source.
 *
 * In order to avoid checking the answers for spam the user is switched to
 * the site administrator account for the duration of the import. See @link
 * https://www.drupal.org/docs/7/security/safely-impersonating-another-user.
 *
 * @param string $source
 *   The URL of the mod-tool.
 *
 * @return boolean
 */
function pw_dialogues_do_import_answers($source) {
  $original_user = $GLOBALS['user'];
  $old_state = drupal_save_session();
  drupal_save_session(FALSE);
  $GLOBALS['user'] = user_load(1);

  $message_feed = feeds_source('dialogue_message_importer');
  $message_feed->addConfig(array(
    'FeedsHTTPFetcher' => array(
      'source' => $source,
    ),
  ));
  while (FEEDS_BATCH_COMPLETE != $message_feed->import()) {
    ;
  }

  $GLOBALS['user'] = $original_user;
  drupal_save_session($old_state);

  watchdog('dialogue_message_importer', 'answers imported from @source', ['@source' => $source]);

  return TRUE;
}

/**
 * Returns query for all questions received by the given account version.
 *
 * @param object $account
 *   The user account (version).
 *
 * @return EntityFieldQuery
 *   The query object.
 */
function pw_dialogues_by_user_revision_query($account) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'node');
  $q->entityCondition('bundle', 'dialogue');
  $q->propertyCondition('status', NODE_PUBLISHED);
  $q->fieldCondition('field_dialogue_recipient', 'target_id', $account->uid);
  $q->fieldCondition('field_parliament', 'tid', pw_profiles_parliament($account)->tid);
  $q->fieldCondition('field_dialogue_before_election', 'value', _pw_user_has_role($account, 'Candidate'));

  return $q;
}

/**
 * Returns query for all questions to politicians in the given parliament.
 *
 * @param object $term
 *   The parliament term.
 *
 * @return SearchApiQuery
 *   The query object.
 *
 * @throws SearchApiException
 *   If the index is unknown or disabled, or some other error was encountered.
 */
function pw_dialogues_by_parliament_query($term) {
  $today = new DateTime();
  $election_date = pw_parliaments_election_date($term);

  $q = search_api_query('dialogue_index')
    ->condition('status', NODE_PUBLISHED)
    ->condition('field_parliament', $term->tid)
    ->condition('field_dialogue_before_election', ($today < $election_date) ? 1 : 0);

  return $q;
}

/**
 * Returns the answers to the given question.
 *
 * @param object $node
 *   The dialogue node.
 *
 * @return array
 *   The answers.
 */
function pw_dialogues_answers($node) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'comment');
  $q->propertyCondition('status', COMMENT_PUBLISHED);
  $q->propertyCondition('nid', $node->nid);
  $q->propertyOrderBy('created');
  $q->addTag('node_access');
  $q->addTag('comment_filter');

  $result = $q->execute();

  if (!empty($result['comment'])) {
    return comment_load_multiple(array_keys($result['comment']));
  }
}

/**
 * Returns a query object with common joins and conditions added.
 *
 * @param object $parliament_term
 *   The parliament term.
 * @param bool $before_election
 *   Whether dialogues before or after the election should be included.
 *
 * @return SelectQuery
 *   The query object.
 */
function pw_dialogues_aggregate_base_query($parliament_term, $before_election) {
  $q = db_select('node', 'n');
  $q->join('field_data_field_parliament', 'p', 'n.nid = p.entity_id');
  $q->join('field_data_field_dialogue_before_election', 'e', 'n.nid = e.entity_id');
  $q->condition('n.type', 'dialogue');
  $q->condition('n.status', NODE_PUBLISHED);
  $q->condition('p.field_parliament_tid', $parliament_term->tid);
  $q->condition('e.field_dialogue_before_election_value', $before_election);

  return $q;
}

/**
 * Returns the average response time in seconds for the given user.
 *
 * @param object $account
 *   The user account.
 *
 * @return int
 *   The average response time in seconds.
 */
function pw_dialogues_average_response_time_by_account($account) {
  $parliament_term = pw_profiles_parliament($account);
  $before_election = _pw_user_has_role($account, 'Candidate') ? 1 : 0;

  $q = pw_dialogues_aggregate_base_query($parliament_term, $before_election);
  $q->join('comment', 'c', 'n.nid = c.nid');
  $q->condition('c.uid', $account->uid);
  $q->addTag('ignore_standard_replies');
  $q->addExpression('AVG(c.created - n.created)');

  return $q->execute()->fetchField();
}

/**
 * Returns the average response time in seconds for the given parliament.
 *
 * @param object $term
 *   The parliament term.
 *
 * @return int
 *   The average response time in seconds.
 */
function pw_dialogues_average_response_time_by_parliament($term) {
  $today = new DateTime();
  $election_date = pw_parliaments_election_date($term);
  $before_election = ($today < $election_date) ? 1 : 0;

  $q = pw_dialogues_aggregate_base_query($term, $before_election);
  $q->join('comment', 'c', 'n.nid = c.nid');
  $q->addTag('ignore_standard_replies');
  $q->addExpression('AVG(c.created - n.created)');

  return $q->execute()->fetchField();
}

/**
 * Returns the number of answered questions for the given parliament.
 *
 * @param object $term
 *   The parliament term.
 *
 * @return int
 *   The number of answered questions.
 */
function pw_dialogues_answered_questions_by_parliament($term) {
  $today = new DateTime();
  $election_date = pw_parliaments_election_date($term);
  $before_election = ($today < $election_date) ? 1 : 0;

  $q = pw_dialogues_aggregate_base_query($term, $before_election);
  $q->join('comment', 'c', 'n.nid = c.nid');
  $q->addTag('ignore_standard_replies');
  $q->addExpression('COUNT(DISTINCT n.nid)');

  return $q->execute()->fetchField();
}

/**
 * Returns number of questions by topic for the given user.
 *
 * @param type $account
 *   The account object.
 *
 * @return array
 *   An associative array with topics as key and numbers as values.
 */
function pw_dialogues_topics_by_user_revision($account) {
  $parliament_term = pw_profiles_parliament($account);
  $before_election = _pw_user_has_role($account, 'Candidate') ? 1 : 0;

  $q = pw_dialogues_aggregate_base_query($parliament_term, $before_election);
  $q->join('field_data_field_dialogue_recipient', 'r', 'n.nid = r.entity_id');
  $q->join('field_data_field_dialogue_topic', 't', 'n.nid = t.entity_id');
  $q->join('taxonomy_term_data', 'td', 't.field_dialogue_topic_tid = td.tid');
  $q->addField('td', 'name');
  $q->addExpression('COUNT(n.nid)', 'count');
  $q->condition('r.field_dialogue_recipient_target_id', $account->uid);
  $q->condition('t.entity_type', 'node');
  $q->groupBy('t.field_dialogue_topic_tid');

  return $q->execute()->fetchAllKeyed();
}

/**
 * Returns number of questions by topic for the given parliament.
 *
 * @param object $term
 *   The parliament term.
 *
 * @return array
 *   An associative array with topics as key and numbers as values.
 */
function pw_dialogues_topics_by_parliament($term) {
  $today = new DateTime();
  $election_date = pw_parliaments_election_date($term);
  $before_election = ($today < $election_date) ? 1 : 0;

  $q = pw_dialogues_aggregate_base_query($term, $before_election);
  $q->join('field_data_field_dialogue_topic', 't', 'n.nid = t.entity_id');
  $q->join('taxonomy_term_data', 'td', 't.field_dialogue_topic_tid = td.tid');
  $q->addField('td', 'name');
  $q->addExpression('COUNT(n.nid)', 'count');
  $q->condition('t.entity_type', 'node');
  $q->groupBy('t.field_dialogue_topic_tid');

  return $q->execute()->fetchAllKeyed();
}

/**
 * Returns answer ratios by party for the given parliament term.
 *
 * @param object $term
 *   The parliament term.
 */
function pw_dialogues_party_ratios_by_parliament($term) {

  $party_ratios = [
    'in_previous_parliament' => [],
    'not_in_previous_parliament' => []
  ];

  $today = new DateTime();
  $election_date = pw_parliaments_election_date($term);
  $before_election = ($today < $election_date) ? 1 : 0;

  $parties_in_previous_parliament = [];
  if ($before_election && $field_previous_parliament = field_get_items('taxonomy_term', $term, 'field_parliament_previous')){
    $previous_parliament = taxonomy_term_load($field_previous_parliament[0]['tid']);
    if ($previous_parliament){
      $q = db_select('user_archive_cache', 'uac');
      $q->join('field_revision_field_user_party', 'f_party', "uac.vid = f_party.revision_id AND f_party.entity_type = 'user'");
      $q->fields('f_party', ['field_user_party_tid']);
      _pw_uac_add_conditions($q, array(
        'parliament' => $previous_parliament->name,
        'roles' => 'deputy',
        'date' => date('Y-m-d'),
      ));
      $q->groupBy('f_party.field_user_party_tid');
      $parties_in_previous_parliament = $q->execute()->fetchCol();
    }
  }

  $q = db_select('user_archive_cache', 'uac');
  $q->addExpression('COUNT(*)', 'count_politicians');
  $q->addExpression('SUM(number_of_questions)', 'count_questions');
  $q->addExpression('SUM(number_of_answers)', 'count_answers');
  $q->addExpression('SUM(number_of_answers) / SUM(number_of_questions) * 100', 'percentage');
  $q->join('field_revision_field_user_party', 'f_party', "uac.vid = f_party.revision_id AND f_party.entity_type = 'user'");
  $q->join('taxonomy_term_data', 't_data', 'f_party.field_user_party_tid = t_data.tid');
  $q->addField('t_data', 'name', 'party');
  $q->addExpression(
    sizeof($parties_in_previous_parliament) > 0
      ? format_string('t_data.tid IN (@party_tids)', ['@party_tids' => implode(',', $parties_in_previous_parliament)])
      : '1',
    'is_top_party');
  $q->orderBy('is_top_party', 'DESC');
  $q->orderBy('percentage', 'DESC');
  $q->orderBy('count_politicians', 'DESC');
  $q->orderBy('party', 'ASC');
  $q->groupBy('t_data.tid');
  _pw_uac_add_conditions($q, array(
    'parliament' => $term->name,
    'roles' => $before_election ? 'candidate' : 'deputy',
    'date' => date('Y-m-d'),
  ));
  $result = $q->execute();

  foreach ($result as $row) {
    if ($row->is_top_party == '1') {
      $party_ratios['in_previous_parliament'][$row->party] = $row;
    }
    else {
      $party_ratios['not_in_previous_parliament'][$row->party] = $row;
    }
  }

  return $party_ratios;
}

/**
 * Returns the account version of the recipient of the question.
 *
 * @param object $node
 *   The dialogue node.
 *
 * @return object
 *   The account version.
 */
function pw_dialogues_recipient_user_revision($node) {
  $recipient = NULL;
  $uid = $node->field_dialogue_recipient[LANGUAGE_NONE][0]['target_id'];
  $before_election = $node->field_dialogue_before_election[LANGUAGE_NONE][0]['value'];

  $result = db_select('user_archive_cache', 'uac')
    ->fields('uac', ['uid', 'vid'])
    ->condition('uid', $uid)
    ->condition('parliament_name', pw_globals_parliament($node)->name)
    ->condition('user_role', $before_election ? 'candidate' : 'deputy')
    ->execute()
    ->fetchAssoc();

  if (!empty($result)) {
    $recipient = user_revision_load($result['uid'], $result['vid']);
  }

  return $recipient;
}

/**
 * Returns array representation of dialogue for serialization.
 *
 * @param object $node
 *   The dialogue node.
 *
 * @return array
 *   The array representation.
 */
function pw_dialogues_to_array($node) {
  if (!empty($node->field_dialogue_topic[LANGUAGE_NONE])) {
    $topic = taxonomy_term_load($node->field_dialogue_topic[LANGUAGE_NONE][0]['tid']);
  }
  $data = [
    'id' => $node->nid,
    'topic' => isset($topic) ? $topic->name : NULL,
  ];
  return $data;
}

/**
 * Returns a query object for fetching dialogues.
 *
 * @param type $parliament_term
 *   The parliament term.
 * @param type $role_name
 *   The role (candidates or deputies).
 *
 * @return SearchApiQuery
 *   The search query object.
 */
function pw_dialogues_base_search_query($parliament_term, $role_name) {
  $q = search_api_query('dialogue_index', ['search_api_facets' => _pw_dialogues_facets()]);
  $q->condition('field_parliament', $parliament_term->tid);

  if ($role_name == 'candidates') {
    $q->condition('field_dialogue_before_election',1);
  }
  elseif ($role_name == 'deputies') {
    $q->condition('field_dialogue_before_election',0);
  }

  return $q;
}

/**
 * Returns HTML for a summary of the search result.
 *
 * @param array $variables
 *   An associative array containing:
 *   - response
 *   - role_name
 *   - filters
 *
 * @return string
 *   The summary of the search result.
 */
function theme_dialogue_search_summary($variables) {
  $output = '';
  $link_options = ['attributes' => ['data-ajax-target' => '#ajax']];

  $options['@count'] = $variables['response']['result count'];
  $options['@data-ajax-target'] = $link_options['attributes']['data-ajax-target'];

  $output .= '<p>';

  $output .= format_plural($variables['response']['result count'], 'Found 1 question', 'Found @count questions');

  if (!empty($variables['filters']['keys'])) {
    $options['!keys'] = l(check_plain($variables['filters']['keys']), current_path(), $link_options + ['query' => _pw_profiles_reject_filter($variables['filters'], 'keys')]);
    $output .= t(', matching: !keys', $options);
  }

  if (!empty(array_filter($variables['filters']))) {
    $output .= ' ' . l(t('Reset all filters'), current_path(), $link_options);
  }

  $output .= '</p>';

  return $output;
}

/**
 * Returns taxonomy term options for the given term IDs.
 *
 * @param array $values
 *   An array of taxonomy term IDs
 *
 * @return array
 *   An array of taxonomy term names keyed by term ID.
 */
function _pw_dialogues_options(array $values) {
  static $terms = [];

  if (empty($terms)) {
    $terms = db_select('taxonomy_term_data', 't')
      ->fields('t', ['tid', 'name'])
      ->condition('vid', 26)
      ->execute()
      ->fetchAllKeyed();
    natsort($terms);
  }

  return array_intersect_key($terms, array_flip($values));
}

/**
 * Returns list of facets for the dialogues page.
 *
 * @return array
 *   An associative array to be used as facets option for a query.
 */
function _pw_dialogues_facets() {
  $common = ['limit' => -1, 'min_count' => 1, 'missing' => TRUE, 'operator' => 'or'];
  return [
    'field_dialogue_topic' => ['field' => 'field_dialogue_topic'] + $common,
  ];
}

/**
 * Returns a sanitized filter list.
 *
 * - Removes empty date filters and converts dates to DateTime objects.
 * - Removes the filter for ignoring standard replies if the
 *   the reply filter is not set.
 *
 * @param array $filters
 *   The raw filters as obtained from drupal_get_query_parameters.
 *
 * @return array
 *   The sanitized filters.
 */
function _pw_dialogues_sanitized_filters($filters) {
  $sanitized_filters = _pw_profiles_reject_filter($filters, 'date');

  try {
    if (!empty($filters['date'][0]) && !empty($filters['date'][1])) {
      $from = new DateTime($filters['date'][0]);
      $to = new DateTime($filters['date'][1]);
      $sanitized_filters['date'][0] = $from->format('Y-m-d');
      $sanitized_filters['date'][1] = $to->format('Y-m-d');
    } elseif (!empty($filters['date'][0])) {
      $from = new DateTime($filters['date'][0]);
      $sanitized_filters['date'][0] = $from->format('Y-m-d');
      $sanitized_filters['date'][1] = $from->add(new DateInterval('P1D'))->format('Y-m-d');
    }
  }
  catch (Exception $e) {
    watchdog_exception('pw_dialogues', $e);
  }

  if (!isset($sanitized_filters['has-reply']) && isset($sanitized_filters['ignore-standard-replies'])) {
    unset($sanitized_filters['ignore-standard-replies']);
  }

  return $sanitized_filters;
}

/**
 * Returns a question node populated from the given XML document.
 *
 * @param DOMDocument $doc
 *   The XML received from the Mod-Tool.
 *
 * @return object
 *   The question node.
 *
 * @throws Exception
 *   Throws an exception if the given document cannot be processed.
 */
function _pw_dialogues_question(DOMDocument $doc) {
  $xpath = new DOMXPath($doc);
  $context_node = $xpath->query('//message[type="question"]')->item(0);

  if (is_null($context_node)) {
    throw new Exception(t('Invalid dialogue'));
  }

  $parliament = array_values(taxonomy_get_term_by_name($xpath->evaluate('string(context)', $context_node), 'parliaments'));
  if (empty($parliament)) {
    throw new Exception(t('Invalid context'));
  }

  $uid = array_values(entity_get_id_by_uuid('user', [$xpath->evaluate('string(recipient.external_id)', $context_node)]));
  if (empty($uid)) {
    throw new Exception(t('Invalid recpient.external_id'));
  }

  $date = new DateTime($xpath->evaluate('string(inserted_date)', $context_node));
  $id = $xpath->evaluate('string(id)', $context_node);

  $node = _pw_dialogues_load_or_create_question($id);
  $node->created = $date->format('U');
  $node->status = $xpath->evaluate('string(status)', $context_node);
  $node->title = 'Frage von ' . $xpath->evaluate('string(sender)', $context_node);
  $node->body = [LANGUAGE_NONE => [0 => [
    'value' => $xpath->evaluate('string(text)', $context_node),
    'summary' => $xpath->evaluate('string(keyworded_text)', $context_node),
  ]]];
  $node->field_dialogue_annotation = [LANGUAGE_NONE => [0 => [
    'value' => $xpath->evaluate('string(annotation.text)', $context_node),
  ]]];
  $node->field_dialogue_before_election = [LANGUAGE_NONE => [0 => [
    'value' => (int) ($date < pw_parliaments_election_date($parliament[0])),
  ]]];
  $node->field_dialogue_id = [LANGUAGE_NONE => [0 => [
    'value' => $xpath->evaluate('string(//dialogue/@id)'),
  ]]];
  $node->field_dialogue_message_id = [LANGUAGE_NONE => [0 => [
    'value' => $id,
  ]]];
  $node->field_dialogue_message_type = [LANGUAGE_NONE => [0 => [
    'value' => $xpath->evaluate('string(type)', $context_node),
  ]]];
  $node->field_dialogue_recipient = [LANGUAGE_NONE => [0 => [
    'target_id' => $uid[0],
  ]]];
  $node->field_dialogue_sender_name = [LANGUAGE_NONE => [0 => [
    'value'=> $xpath->evaluate('string(sender)', $context_node),
  ]]];
  $node->field_parliament = [LANGUAGE_NONE => [0 => [
    'tid' => $parliament[0]->tid,
  ]]];
  $node->field_dialogue_documents[LANGUAGE_NONE] = [];
  foreach ($xpath->query('documents/documents_item', $context_node) as $item) {
    $node->field_dialogue_documents[LANGUAGE_NONE][] = ['url' => trim($item->textContent)];
  }
  $node->field_dialogue_tags[LANGUAGE_NONE] = [];
  foreach ($xpath->query('tags/tags_item', $context_node) as $item) {
    $term = array_values(taxonomy_get_term_by_name(trim($item->textContent), 'dialogue_tags'));
    if (!empty($term)) {
      $node->field_dialogue_tags[LANGUAGE_NONE][] = ['tid' => $term[0]->tid];
    }
  };
  $topic = array_values(taxonomy_get_term_by_name($xpath->evaluate('string(topic)', $context_node), 'dialogue_topics'));
  if (!empty($topic)) {
    $node->field_dialogue_topic = [LANGUAGE_NONE => [0 => [
      'tid' => $topic[0]->tid,
    ]]];
  }

  return $node;
}

/**
 * Returns answers as comments populated from the given XML document.
 *
 * @param DOMDocument $doc
 *   The XML received from the Mod-Tool.
 *
 * @param object
 *   The question node.
 *
 * @return array
 *   The answers as comments.
 *
 * @throws Exception
 *   Throws an exception if the given document cannot be processed.
 */
function _pw_dialogues_answers(DOMDocument $doc, $question) {
  $xpath = new DOMXPath($doc);
  $answers = [];

  foreach ($xpath->query('//message[type="answer"]') as $context_node) {
    $uid = array_values(entity_get_id_by_uuid('user', [$xpath->evaluate('string(sender.external_id)', $context_node)]));
    if (empty($uid)) {
      throw new Exception(t('Invalid sender.external_id'));
    }

    $date = new DateTime($xpath->evaluate('string(inserted_date)', $context_node));
    $id = $xpath->evaluate('string(id)', $context_node);

    $comment = _pw_dialogues_load_or_create_answer($id, $question);
    $comment->created = $date->format('U');
    $comment->status = $xpath->evaluate('string(status)', $context_node);
    $comment->subject = 'Antwort von ' . $xpath->evaluate('string(sender)', $context_node);
    $comment->uid = $uid;
    $comment->field_dialogue_annotation = [LANGUAGE_NONE => [0 => [
      'value' => $xpath->evaluate('string(annotation.text)', $context_node),
    ]]];
    $comment->field_dialogue_comment_body = [LANGUAGE_NONE => [0 => [
      'value' => $xpath->evaluate('string(text)', $context_node),
      'summary' => $xpath->evaluate('string(keyworded_text)', $context_node),
    ]]];
    $comment->field_dialogue_id = [LANGUAGE_NONE => [0 => [
      'value' => $xpath->evaluate('string(//dialogue/@id)'),
    ]]];
    $comment->field_dialogue_message_id = [LANGUAGE_NONE => [0 => [
      'value' => $id,
    ]]];
    $comment->field_dialogue_message_type = [LANGUAGE_NONE => [0 => [
      'value' => $xpath->evaluate('string(type)', $context_node),
    ]]];
    $comment->field_dialogue_sender_fullname = [LANGUAGE_NONE => [0 => [
      'value' => $xpath->evaluate('string(sender)', $context_node),
    ]]];
    $comment->field_dialogue_documents[LANGUAGE_NONE] = [];
    foreach ($xpath->query('documents/documents_item', $context_node) as $item) {
      $comment->field_dialogue_documents[LANGUAGE_NONE][] = ['url' => trim($item->textContent)];
    }
    $comment->field_dialogue_tags[LANGUAGE_NONE] = [];
    foreach ($xpath->query('tags/tags_item', $context_node) as $item) {
      $term = array_values(taxonomy_get_term_by_name(trim($item->textContent), 'dialogue_tags'));
      if (!empty($term)) {
        $comment->field_dialogue_tags[LANGUAGE_NONE][] = ['tid' => $term[0]->tid];
      }
    };
    $topic = array_values(taxonomy_get_term_by_name($xpath->evaluate('string(topic)', $context_node), 'dialogue_topics'));
    if (!empty($topic)) {
      $comment->field_dialogue_topic = [LANGUAGE_NONE => [0 => [
        'tid' => $topic[0]->tid,
      ]]];
    }
    $answers[] = $comment;
  }

  return $answers;
}

/**
 * Returns a fully-populated question or a new node.
 *
 * @param $message_id
 *   The message_id of the question.
 *
 * @return object
 *   The question node.
 */
function _pw_dialogues_load_or_create_question($message_id) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'node');
  $q->entityCondition('bundle', 'dialogue');
  $q->fieldCondition('field_dialogue_message_id', 'value', $message_id);
  $result = $q->execute();

  if (!empty($result['node'])) {
    $node = node_load(key($result['node']));
  }
  else {
    $node = new stdClass();
    $node->language = LANGUAGE_NONE;
    $node->type = 'dialogue';
    node_object_prepare($node);
  }

  return $node;
}

/**
 * Returns a fully populated answer or a new comment.
 *
 * @param $message_id
 *   The message_id of the answer.
 *
 * @param $question
 *   The question node.
 *
 * @return object
 *   The answer comment.
 */
function _pw_dialogues_load_or_create_answer($message_id, $question) {
  $q = new EntityFieldQuery();
  $q->entityCondition('entity_type', 'comment');
  $q->entityCondition('bundle', 'comment_node_dialogue');
  $q->fieldCondition('field_dialogue_message_id', 'value', $message_id);
  $result = $q->execute();

  if (!empty($result['comment'])) {
    $comment = comment_load(key($result['comment']));
    $comment->changed = REQUEST_TIME;
  }
  else {
    $comment = new stdClass();
    $comment->nid = $question->nid;
  }

  return $comment;
}
