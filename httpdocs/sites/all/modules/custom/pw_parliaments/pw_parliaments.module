<?php
/**
 * @file
 * Code for the PW Parliaments feature.
 */

include_once 'pw_parliaments.features.inc';

/**
 * Implements hook_taxonomy_term_presave().
 */
function pw_parliaments_taxonomy_term_presave($term) {
  // check if is parliaments vocabulary
  if($term->vid == 18 && module_exists('pw_userarchives')){
    db_delete('user_archive_cache')
      ->condition('parliament_name', $term->original->name)
      ->execute();
  }
}

/**
 * Implements hook_taxonomy_term_update().
 */
function pw_parliaments_taxonomy_term_update($term) {
  // check if is parliaments vocabulary
  if($term->vid == 18 && module_exists('pw_userarchives')){
    pw_userarchives_cron();
    if(module_exists('pw_cache')){
      $query = db_select('user_archive_cache', 'uac')
        ->fields('uac', array('user_name', 'vid', 'actual_profile'))
        ->condition('parliament_name', $term->name);
      $result = $query->execute();
      if($result->rowCount() > 0){
        while($row = $result->fetchAssoc()){
          if($row['actual_profile'] == 1){
            $expire_paths[] = 'profile/'.$row['user_name'];
          }
          else{
            $expire_paths[] = 'profile/'.$row['user_name'].'/archive/'.$row['vid'];
          }
        }
        pw_cache_expire_cache($expire_paths);
      }
    }
  }
}

/**
 * Implements hook_block_list_alter().
 *
 * Removes title block from taxonomy term pages of funded parliaments.
 */
function pw_parliaments_block_list_alter(&$blocks) {
  $term = menu_get_object('taxonomy_term', 2);

  if (!isset($term) || !pw_globals_parliament_is_funded($term)) {
    return;
  }

  foreach ($blocks as $key => $block) {
    if ($block->module == 'pw_globals' && $block->delta == 'title') {
      unset($blocks[$key]);
    }
  }
}
